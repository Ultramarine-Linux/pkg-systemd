From 4cbb372cd734d9e3e125a42b12a9e71caf1632a6 Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Thu, 11 Mar 2021 21:49:44 +0100
Subject: [PATCH] syscall: disable epoll_pwait2() for now on 32bit

Alternative to #18973.
---
 src/basic/missing_syscall.h | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/basic/missing_syscall.h b/src/basic/missing_syscall.h
index 13843248045..8158a75a78d 100644
--- a/src/basic/missing_syscall.h
+++ b/src/basic/missing_syscall.h
@@ -407,6 +407,13 @@ static inline int missing_epoll_pwait2(
                 const sigset_t *sigset) {
 
 #  if defined(__NR_epoll_pwait2) && HAVE_LINUX_TIME_TYPES_H
+#    if __SIZEOF_LONG__ == 4
+// Someone with an interest in 32bit systems, please have a look at this, and figure out why this hangs on 32bit systems.
+// My educated guess: might be because of issues with the __kernel_timespec translation or because of incorrectly sized sigset_t array.
+#      pragma message "epoll_pwait2() appears to be broken on 32bit archs, someone please have a look!"
+        errno = ENOSYS;
+        return -1;
+#    else
         if (timeout) {
                 /* Convert from userspace timespec to kernel timespec */
                 struct __kernel_timespec ts = {
@@ -417,6 +424,7 @@ static inline int missing_epoll_pwait2(
                 return syscall(__NR_epoll_pwait2, fd, events, maxevents, &ts, sigset, sigset ? KERNEL_NSIG_BYTES : 0);
         } else
                 return syscall(__NR_epoll_pwait2, fd, events, maxevents, NULL, sigset, sigset ? KERNEL_NSIG_BYTES : 0);
+#    endif
 #  else
         errno = ENOSYS;
         return -1;
