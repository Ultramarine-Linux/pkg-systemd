From 7f9154f419bb4fe4a8dbf52d5655fc5bfe4323ab Mon Sep 17 00:00:00 2001
From: Michal Schmidt <mschmidt@redhat.com>
Date: Sun, 15 Jan 2012 12:04:08 +0100
Subject: [PATCH] unit: remove union Unit

Now that objects of all unit types are allocated the exact amount of
memory they need, the Unit union has lost its purpose. Remove it.

"Unit" is a more natural name for the base unit class than "Meta", so
rename Meta to Unit.

Access to members of the base class gets simplified.
(cherry picked from commit ac155bb885f9ea8aac3979a6b2686f0c8a9cc6e3)

Conflicts:

	src/job.c
	src/service.c
	src/unit.c
---
 src/automount.c                  |   16 +-
 src/automount.h                  |    2 +-
 src/cgroup.c                     |   10 +-
 src/dbus-automount.c             |    5 +-
 src/dbus-device.c                |    3 +-
 src/dbus-job.c                   |    2 +-
 src/dbus-manager.c               |   34 +-
 src/dbus-mount.c                 |   18 +-
 src/dbus-path.c                  |   12 +-
 src/dbus-service.c               |   53 ++--
 src/dbus-snapshot.c              |    4 +-
 src/dbus-socket.c                |   62 ++--
 src/dbus-swap.c                  |   13 +-
 src/dbus-timer.c                 |   10 +-
 src/dbus-unit.c                  |   70 ++--
 src/dbus-unit.h                  |   84 +++---
 src/dbus.c                       |    2 +-
 src/device.c                     |    2 +-
 src/device.h                     |    2 +-
 src/job.c                        |  100 +++---
 src/load-dropin.c                |   16 +-
 src/load-fragment-gperf.gperf.m4 |   20 +-
 src/load-fragment.c              |   62 ++--
 src/main.c                       |   16 +-
 src/manager.c                    |  208 ++++++------
 src/manager.h                    |   12 +-
 src/mount.c                      |   60 ++--
 src/mount.h                      |    2 +-
 src/path.c                       |   22 +-
 src/path.h                       |    2 +-
 src/service.c                    |   92 +++---
 src/service.h                    |    2 +-
 src/snapshot.c                   |   14 +-
 src/snapshot.h                   |    2 +-
 src/socket.c                     |   46 ++--
 src/socket.h                     |    2 +-
 src/swap.c                       |   32 +-
 src/swap.h                       |    2 +-
 src/target.c                     |    4 +-
 src/target.h                     |    2 +-
 src/timer.c                      |   28 +-
 src/timer.h                      |    2 +-
 src/unit.c                       |  718 +++++++++++++++++++-------------------
 src/unit.h                       |   35 +--
 44 files changed, 949 insertions(+), 956 deletions(-)

diff --git a/src/automount.c b/src/automount.c
index d09c379..e921123 100644
--- a/src/automount.c
+++ b/src/automount.c
@@ -52,7 +52,7 @@ static void automount_init(Unit *u) {
         Automount *a = AUTOMOUNT(u);
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         a->pipe_watch.fd = a->pipe_fd = -1;
         a->pipe_watch.type = WATCH_INVALID;
@@ -137,7 +137,7 @@ int automount_add_one_mount_link(Automount *a, Mount *m) {
 }
 
 static int automount_add_mount_links(Automount *a) {
-        Meta *other;
+        Unit *other;
         int r;
 
         assert(a);
@@ -198,17 +198,17 @@ static int automount_load(Unit *u) {
         Automount *a = AUTOMOUNT(u);
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         /* Load a .automount file */
         if ((r = unit_load_fragment_and_dropin_optional(u)) < 0)
                 return r;
 
-        if (u->meta.load_state == UNIT_LOADED) {
+        if (u->load_state == UNIT_LOADED) {
                 Unit *x;
 
                 if (!a->where)
-                        if (!(a->where = unit_name_to_path(u->meta.id)))
+                        if (!(a->where = unit_name_to_path(u->id)))
                                 return -ENOMEM;
 
                 path_kill_slashes(a->where);
@@ -263,7 +263,7 @@ static int automount_coldplug(Unit *u) {
 
         if (a->deserialized_state != a->state) {
 
-                if ((r = open_dev_autofs(u->meta.manager)) < 0)
+                if ((r = open_dev_autofs(u->manager)) < 0)
                         return r;
 
                 if (a->deserialized_state == AUTOMOUNT_WAITING ||
@@ -617,11 +617,11 @@ static int automount_start(Unit *u) {
         assert(a->state == AUTOMOUNT_DEAD || a->state == AUTOMOUNT_FAILED);
 
         if (path_is_mount_point(a->where, false)) {
-                log_error("Path %s is already a mount point, refusing start for %s", a->where, u->meta.id);
+                log_error("Path %s is already a mount point, refusing start for %s", a->where, u->id);
                 return -EEXIST;
         }
 
-        if (UNIT_DEREF(a->mount)->meta.load_state != UNIT_LOADED)
+        if (UNIT_DEREF(a->mount)->load_state != UNIT_LOADED)
                 return -ENOENT;
 
         a->failure = false;
diff --git a/src/automount.h b/src/automount.h
index c6326ed..8334c97 100644
--- a/src/automount.h
+++ b/src/automount.h
@@ -36,7 +36,7 @@ typedef enum AutomountState {
 } AutomountState;
 
 struct Automount {
-        Meta meta;
+        Unit meta;
 
         AutomountState state, deserialized_state;
 
diff --git a/src/cgroup.c b/src/cgroup.c
index 4bbb54f..d7c5bdb 100644
--- a/src/cgroup.c
+++ b/src/cgroup.c
@@ -66,16 +66,16 @@ void cgroup_bonding_free(CGroupBonding *b, bool remove_or_trim) {
         if (b->unit) {
                 CGroupBonding *f;
 
-                LIST_REMOVE(CGroupBonding, by_unit, b->unit->meta.cgroup_bondings, b);
+                LIST_REMOVE(CGroupBonding, by_unit, b->unit->cgroup_bondings, b);
 
                 if (streq(b->controller, SYSTEMD_CGROUP_CONTROLLER)) {
-                        assert_se(f = hashmap_get(b->unit->meta.manager->cgroup_bondings, b->path));
+                        assert_se(f = hashmap_get(b->unit->manager->cgroup_bondings, b->path));
                         LIST_REMOVE(CGroupBonding, by_path, f, b);
 
                         if (f)
-                                hashmap_replace(b->unit->meta.manager->cgroup_bondings, b->path, f);
+                                hashmap_replace(b->unit->manager->cgroup_bondings, b->path, f);
                         else
-                                hashmap_remove(b->unit->meta.manager->cgroup_bondings, b->path);
+                                hashmap_remove(b->unit->manager->cgroup_bondings, b->path);
                 }
         }
 
@@ -385,7 +385,7 @@ int cgroup_notify_empty(Manager *m, const char *group) {
 
                 if (t > 0) {
                         /* If it is empty, let's delete it */
-                        cgroup_bonding_trim_list(b->unit->meta.cgroup_bondings, true);
+                        cgroup_bonding_trim_list(b->unit->cgroup_bondings, true);
 
                         if (UNIT_VTABLE(b->unit)->cgroup_notify_empty)
                                 UNIT_VTABLE(b->unit)->cgroup_notify_empty(b->unit);
diff --git a/src/dbus-automount.c b/src/dbus-automount.c
index 8268425..62e8a5f 100644
--- a/src/dbus-automount.c
+++ b/src/dbus-automount.c
@@ -46,10 +46,11 @@
 const char bus_automount_interface[] _introspect_("Automount") = BUS_AUTOMOUNT_INTERFACE;
 
 DBusHandlerResult bus_automount_message_handler(Unit *u, DBusConnection *c, DBusMessage *message) {
+        Automount *am = AUTOMOUNT(u);
         const BusProperty properties[] = {
                 BUS_UNIT_PROPERTIES,
-                { "org.freedesktop.systemd1.Automount", "Where", bus_property_append_string,       "s", u->automount.where           },
-                { "org.freedesktop.systemd1.Automount", "DirectoryMode", bus_property_append_mode, "u", &u->automount.directory_mode },
+                { "org.freedesktop.systemd1.Automount", "Where", bus_property_append_string,       "s", am->where           },
+                { "org.freedesktop.systemd1.Automount", "DirectoryMode", bus_property_append_mode, "u", &am->directory_mode },
                 { NULL, NULL, NULL, NULL, NULL }
         };
 
diff --git a/src/dbus-device.c b/src/dbus-device.c
index f85ad2d..dd5d0e9 100644
--- a/src/dbus-device.c
+++ b/src/dbus-device.c
@@ -48,9 +48,10 @@ const char bus_device_invalidating_properties[] =
         "SysFSPath\0";
 
 DBusHandlerResult bus_device_message_handler(Unit *u, DBusConnection *c, DBusMessage *message) {
+        Device *d = DEVICE(u);
         const BusProperty properties[] = {
                 BUS_UNIT_PROPERTIES,
-                { "org.freedesktop.systemd1.Device", "SysFSPath", bus_property_append_string, "s", u->device.sysfs },
+                { "org.freedesktop.systemd1.Device", "SysFSPath", bus_property_append_string, "s", d->sysfs },
                 { NULL, NULL, NULL, NULL, NULL }
         };
 
diff --git a/src/dbus-job.c b/src/dbus-job.c
index 2308be3..82a23a8 100644
--- a/src/dbus-job.c
+++ b/src/dbus-job.c
@@ -71,7 +71,7 @@ static int bus_job_append_unit(DBusMessageIter *i, const char *property, void *d
         if (!(p = unit_dbus_path(j->unit)))
                 return -ENOMEM;
 
-        if (!dbus_message_iter_append_basic(&sub, DBUS_TYPE_STRING, &j->unit->meta.id) ||
+        if (!dbus_message_iter_append_basic(&sub, DBUS_TYPE_STRING, &j->unit->id) ||
             !dbus_message_iter_append_basic(&sub, DBUS_TYPE_OBJECT_PATH, &p)) {
                 free(p);
                 return -ENOMEM;
diff --git a/src/dbus-manager.c b/src/dbus-manager.c
index 7b68156..710cbcb 100644
--- a/src/dbus-manager.c
+++ b/src/dbus-manager.c
@@ -777,39 +777,39 @@ static DBusHandlerResult bus_manager_message_handler(DBusConnection *connection,
                         uint32_t job_id;
                         Unit *f;
 
-                        if (k != u->meta.id)
+                        if (k != u->id)
                                 continue;
 
                         if (!dbus_message_iter_open_container(&sub, DBUS_TYPE_STRUCT, NULL, &sub2))
                                 goto oom;
 
                         description = unit_description(u);
-                        load_state = unit_load_state_to_string(u->meta.load_state);
+                        load_state = unit_load_state_to_string(u->load_state);
                         active_state = unit_active_state_to_string(unit_active_state(u));
                         sub_state = unit_sub_state_to_string(u);
 
                         f = unit_following(u);
-                        following = f ? f->meta.id : "";
+                        following = f ? f->id : "";
 
                         if (!(u_path = unit_dbus_path(u)))
                                 goto oom;
 
-                        if (u->meta.job) {
-                                job_id = (uint32_t) u->meta.job->id;
+                        if (u->job) {
+                                job_id = (uint32_t) u->job->id;
 
-                                if (!(j_path = job_dbus_path(u->meta.job))) {
+                                if (!(j_path = job_dbus_path(u->job))) {
                                         free(u_path);
                                         goto oom;
                                 }
 
-                                sjob_type = job_type_to_string(u->meta.job->type);
+                                sjob_type = job_type_to_string(u->job->type);
                         } else {
                                 job_id = 0;
                                 j_path = u_path;
                                 sjob_type = "";
                         }
 
-                        if (!dbus_message_iter_append_basic(&sub2, DBUS_TYPE_STRING, &u->meta.id) ||
+                        if (!dbus_message_iter_append_basic(&sub2, DBUS_TYPE_STRING, &u->id) ||
                             !dbus_message_iter_append_basic(&sub2, DBUS_TYPE_STRING, &description) ||
                             !dbus_message_iter_append_basic(&sub2, DBUS_TYPE_STRING, &load_state) ||
                             !dbus_message_iter_append_basic(&sub2, DBUS_TYPE_STRING, &active_state) ||
@@ -820,13 +820,13 @@ static DBusHandlerResult bus_manager_message_handler(DBusConnection *connection,
                             !dbus_message_iter_append_basic(&sub2, DBUS_TYPE_STRING, &sjob_type) ||
                             !dbus_message_iter_append_basic(&sub2, DBUS_TYPE_OBJECT_PATH, &j_path)) {
                                 free(u_path);
-                                if (u->meta.job)
+                                if (u->job)
                                         free(j_path);
                                 goto oom;
                         }
 
                         free(u_path);
-                        if (u->meta.job)
+                        if (u->job)
                                 free(j_path);
 
                         if (!dbus_message_iter_close_container(&sub, &sub2))
@@ -871,7 +871,7 @@ static DBusHandlerResult bus_manager_message_handler(DBusConnection *connection,
                         }
 
                         if (!dbus_message_iter_append_basic(&sub2, DBUS_TYPE_UINT32, &id) ||
-                            !dbus_message_iter_append_basic(&sub2, DBUS_TYPE_STRING, &j->unit->meta.id) ||
+                            !dbus_message_iter_append_basic(&sub2, DBUS_TYPE_STRING, &j->unit->id) ||
                             !dbus_message_iter_append_basic(&sub2, DBUS_TYPE_STRING, &type) ||
                             !dbus_message_iter_append_basic(&sub2, DBUS_TYPE_STRING, &state) ||
                             !dbus_message_iter_append_basic(&sub2, DBUS_TYPE_OBJECT_PATH, &j_path) ||
@@ -1013,7 +1013,7 @@ static DBusHandlerResult bus_manager_message_handler(DBusConnection *connection,
                 HASHMAP_FOREACH_KEY(u, k, m->units, i) {
                         char *p;
 
-                        if (k != u->meta.id)
+                        if (k != u->id)
                                 continue;
 
                         if (!(p = bus_path_escape(k))) {
@@ -1447,8 +1447,8 @@ static DBusHandlerResult bus_manager_message_handler(DBusConnection *connection,
 
                 if (old_name)
                         if (!(u = manager_get_unit(m, old_name)) ||
-                            !u->meta.job ||
-                            u->meta.job->type != JOB_START) {
+                            !u->job ||
+                            u->job->type != JOB_START) {
                                 dbus_set_error(&error, BUS_ERROR_NO_SUCH_JOB, "No job queued for unit %s", old_name);
                                 return bus_send_error_reply(connection, message, &error, -ENOENT);
                         }
@@ -1469,10 +1469,10 @@ static DBusHandlerResult bus_manager_message_handler(DBusConnection *connection,
                                 job_type = JOB_RELOAD;
                 }
 
-                if ((job_type == JOB_START && u->meta.refuse_manual_start) ||
-                    (job_type == JOB_STOP && u->meta.refuse_manual_stop) ||
+                if ((job_type == JOB_START && u->refuse_manual_start) ||
+                    (job_type == JOB_STOP && u->refuse_manual_stop) ||
                     ((job_type == JOB_RESTART || job_type == JOB_TRY_RESTART) &&
-                     (u->meta.refuse_manual_start || u->meta.refuse_manual_stop))) {
+                     (u->refuse_manual_start || u->refuse_manual_stop))) {
                         dbus_set_error(&error, BUS_ERROR_ONLY_BY_DEPENDENCY, "Operation refused, may be requested by dependency only.");
                         return bus_send_error_reply(connection, message, &error, -EPERM);
                 }
diff --git a/src/dbus-mount.c b/src/dbus-mount.c
index cfbfd45..60f1e92 100644
--- a/src/dbus-mount.c
+++ b/src/dbus-mount.c
@@ -136,20 +136,20 @@ static int bus_mount_append_type(DBusMessageIter *i, const char *property, void
 }
 
 DBusHandlerResult bus_mount_message_handler(Unit *u, DBusConnection *c, DBusMessage *message) {
-
+        Mount *m = MOUNT(u);
         const BusProperty properties[] = {
                 BUS_UNIT_PROPERTIES,
-                { "org.freedesktop.systemd1.Mount", "Where",         bus_property_append_string, "s", u->mount.where           },
+                { "org.freedesktop.systemd1.Mount", "Where",         bus_property_append_string, "s", m->where                 },
                 { "org.freedesktop.systemd1.Mount", "What",          bus_mount_append_what,      "s", u                        },
                 { "org.freedesktop.systemd1.Mount", "Options",       bus_mount_append_options,   "s", u                        },
                 { "org.freedesktop.systemd1.Mount", "Type",          bus_mount_append_type,      "s", u                        },
-                { "org.freedesktop.systemd1.Mount", "TimeoutUSec",   bus_property_append_usec,   "t", &u->mount.timeout_usec   },
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Mount", u->mount.exec_command+MOUNT_EXEC_MOUNT,   "ExecMount"),
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Mount", u->mount.exec_command+MOUNT_EXEC_UNMOUNT, "ExecUnmount"),
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Mount", u->mount.exec_command+MOUNT_EXEC_REMOUNT, "ExecRemount"),
-                BUS_EXEC_CONTEXT_PROPERTIES("org.freedesktop.systemd1.Mount", u->mount.exec_context),
-                { "org.freedesktop.systemd1.Mount", "ControlPID",    bus_property_append_pid,    "u", &u->mount.control_pid    },
-                { "org.freedesktop.systemd1.Mount", "DirectoryMode", bus_property_append_mode,   "u", &u->mount.directory_mode },
+                { "org.freedesktop.systemd1.Mount", "TimeoutUSec",   bus_property_append_usec,   "t", &m->timeout_usec         },
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Mount", m->exec_command+MOUNT_EXEC_MOUNT,   "ExecMount"),
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Mount", m->exec_command+MOUNT_EXEC_UNMOUNT, "ExecUnmount"),
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Mount", m->exec_command+MOUNT_EXEC_REMOUNT, "ExecRemount"),
+                BUS_EXEC_CONTEXT_PROPERTIES("org.freedesktop.systemd1.Mount", m->exec_context),
+                { "org.freedesktop.systemd1.Mount", "ControlPID",    bus_property_append_pid,    "u", &m->control_pid          },
+                { "org.freedesktop.systemd1.Mount", "DirectoryMode", bus_property_append_mode,   "u", &m->directory_mode       },
                 { NULL, NULL, NULL, NULL, NULL }
         };
 
diff --git a/src/dbus-path.c b/src/dbus-path.c
index f67b5a2..53a5b42 100644
--- a/src/dbus-path.c
+++ b/src/dbus-path.c
@@ -80,24 +80,26 @@ static int bus_path_append_paths(DBusMessageIter *i, const char *property, void
 
 static int bus_path_append_unit(DBusMessageIter *i, const char *property, void *data) {
         Unit *u = data;
+        Path *p = PATH(u);
         const char *t;
 
         assert(i);
         assert(property);
         assert(u);
 
-        t = UNIT_DEREF(u->path.unit) ? UNIT_DEREF(u->path.unit)->meta.id : "";
+        t = UNIT_DEREF(p->unit) ? UNIT_DEREF(p->unit)->id : "";
 
         return dbus_message_iter_append_basic(i, DBUS_TYPE_STRING, &t) ? 0 : -ENOMEM;
 }
 
 DBusHandlerResult bus_path_message_handler(Unit *u, DBusConnection *c, DBusMessage *message) {
+        Path *p = PATH(u);
         const BusProperty properties[] = {
                 BUS_UNIT_PROPERTIES,
-                { "org.freedesktop.systemd1.Path", "Unit",          bus_path_append_unit,     "s",     u                        },
-                { "org.freedesktop.systemd1.Path", "Paths",         bus_path_append_paths,    "a(ss)", u                        },
-                { "org.freedesktop.systemd1.Path", "MakeDirectory", bus_property_append_bool, "b",     &u->path.make_directory  },
-                { "org.freedesktop.systemd1.Path", "DirectoryMode", bus_property_append_mode, "u",     &u->path.directory_mode  },
+                { "org.freedesktop.systemd1.Path", "Unit",          bus_path_append_unit,     "s",     u                   },
+                { "org.freedesktop.systemd1.Path", "Paths",         bus_path_append_paths,    "a(ss)", u                   },
+                { "org.freedesktop.systemd1.Path", "MakeDirectory", bus_property_append_bool, "b",     &p->make_directory  },
+                { "org.freedesktop.systemd1.Path", "DirectoryMode", bus_property_append_mode, "u",     &p->directory_mode  },
                 { NULL, NULL, NULL, NULL, NULL }
         };
 
diff --git a/src/dbus-service.c b/src/dbus-service.c
index 373e3f5..2157c2b 100644
--- a/src/dbus-service.c
+++ b/src/dbus-service.c
@@ -95,36 +95,37 @@ static DEFINE_BUS_PROPERTY_APPEND_ENUM(bus_service_append_restart, service_resta
 static DEFINE_BUS_PROPERTY_APPEND_ENUM(bus_service_append_notify_access, notify_access, NotifyAccess);
 
 DBusHandlerResult bus_service_message_handler(Unit *u, DBusConnection *connection, DBusMessage *message) {
+        Service *s = SERVICE(u);
         const BusProperty properties[] = {
                 BUS_UNIT_PROPERTIES,
-                { "org.freedesktop.systemd1.Service", "Type",                   bus_service_append_type,    "s", &u->service.type                      },
-                { "org.freedesktop.systemd1.Service", "Restart",                bus_service_append_restart, "s", &u->service.restart                   },
-                { "org.freedesktop.systemd1.Service", "PIDFile",                bus_property_append_string, "s", u->service.pid_file                   },
-                { "org.freedesktop.systemd1.Service", "NotifyAccess",           bus_service_append_notify_access, "s", &u->service.notify_access       },
-                { "org.freedesktop.systemd1.Service", "RestartUSec",            bus_property_append_usec,   "t", &u->service.restart_usec              },
-                { "org.freedesktop.systemd1.Service", "TimeoutUSec",            bus_property_append_usec,   "t", &u->service.timeout_usec              },
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", u->service.exec_command[SERVICE_EXEC_START_PRE],  "ExecStartPre"),
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", u->service.exec_command[SERVICE_EXEC_START],      "ExecStart"),
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", u->service.exec_command[SERVICE_EXEC_START_POST], "ExecStartPost"),
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", u->service.exec_command[SERVICE_EXEC_RELOAD],     "ExecReload"),
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", u->service.exec_command[SERVICE_EXEC_STOP],       "ExecStop"),
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", u->service.exec_command[SERVICE_EXEC_STOP_POST],  "ExecStopPost"),
-                BUS_EXEC_CONTEXT_PROPERTIES("org.freedesktop.systemd1.Service", u->service.exec_context),
-                { "org.freedesktop.systemd1.Service", "PermissionsStartOnly",   bus_property_append_bool,   "b", &u->service.permissions_start_only    },
-                { "org.freedesktop.systemd1.Service", "RootDirectoryStartOnly", bus_property_append_bool,   "b", &u->service.root_directory_start_only },
-                { "org.freedesktop.systemd1.Service", "RemainAfterExit",        bus_property_append_bool,   "b", &u->service.remain_after_exit         },
-                { "org.freedesktop.systemd1.Service", "GuessMainPID",           bus_property_append_bool,   "b", &u->service.guess_main_pid            },
-               BUS_EXEC_STATUS_PROPERTIES("org.freedesktop.systemd1.Service", u->service.main_exec_status, "ExecMain"),
-                { "org.freedesktop.systemd1.Service", "MainPID",                bus_property_append_pid,    "u", &u->service.main_pid                  },
-                { "org.freedesktop.systemd1.Service", "ControlPID",             bus_property_append_pid,    "u", &u->service.control_pid               },
-                { "org.freedesktop.systemd1.Service", "BusName",                bus_property_append_string, "s", u->service.bus_name                   },
-                { "org.freedesktop.systemd1.Service", "StatusText",             bus_property_append_string, "s", u->service.status_text                },
+                { "org.freedesktop.systemd1.Service", "Type",                   bus_service_append_type,    "s", &s->type                      },
+                { "org.freedesktop.systemd1.Service", "Restart",                bus_service_append_restart, "s", &s->restart                   },
+                { "org.freedesktop.systemd1.Service", "PIDFile",                bus_property_append_string, "s", s->pid_file                   },
+                { "org.freedesktop.systemd1.Service", "NotifyAccess",           bus_service_append_notify_access, "s", &s->notify_access       },
+                { "org.freedesktop.systemd1.Service", "RestartUSec",            bus_property_append_usec,   "t", &s->restart_usec              },
+                { "org.freedesktop.systemd1.Service", "TimeoutUSec",            bus_property_append_usec,   "t", &s->timeout_usec              },
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", s->exec_command[SERVICE_EXEC_START_PRE],  "ExecStartPre"),
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", s->exec_command[SERVICE_EXEC_START],      "ExecStart"),
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", s->exec_command[SERVICE_EXEC_START_POST], "ExecStartPost"),
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", s->exec_command[SERVICE_EXEC_RELOAD],     "ExecReload"),
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", s->exec_command[SERVICE_EXEC_STOP],       "ExecStop"),
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Service", s->exec_command[SERVICE_EXEC_STOP_POST],  "ExecStopPost"),
+                BUS_EXEC_CONTEXT_PROPERTIES("org.freedesktop.systemd1.Service", s->exec_context),
+                { "org.freedesktop.systemd1.Service", "PermissionsStartOnly",   bus_property_append_bool,   "b", &s->permissions_start_only    },
+                { "org.freedesktop.systemd1.Service", "RootDirectoryStartOnly", bus_property_append_bool,   "b", &s->root_directory_start_only },
+                { "org.freedesktop.systemd1.Service", "RemainAfterExit",        bus_property_append_bool,   "b", &s->remain_after_exit         },
+                { "org.freedesktop.systemd1.Service", "GuessMainPID",           bus_property_append_bool,   "b", &s->guess_main_pid            },
+               BUS_EXEC_STATUS_PROPERTIES("org.freedesktop.systemd1.Service", s->main_exec_status, "ExecMain"),
+                { "org.freedesktop.systemd1.Service", "MainPID",                bus_property_append_pid,    "u", &s->main_pid                  },
+                { "org.freedesktop.systemd1.Service", "ControlPID",             bus_property_append_pid,    "u", &s->control_pid               },
+                { "org.freedesktop.systemd1.Service", "BusName",                bus_property_append_string, "s", s->bus_name                   },
+                { "org.freedesktop.systemd1.Service", "StatusText",             bus_property_append_string, "s", s->status_text                },
 #ifdef HAVE_SYSV_COMPAT
-                { "org.freedesktop.systemd1.Service", "SysVRunLevels",          bus_property_append_string, "s", u->service.sysv_runlevels             },
-                { "org.freedesktop.systemd1.Service", "SysVStartPriority",      bus_property_append_int,    "i", &u->service.sysv_start_priority       },
-                { "org.freedesktop.systemd1.Service", "SysVPath",               bus_property_append_string, "s", u->service.sysv_path                  },
+                { "org.freedesktop.systemd1.Service", "SysVRunLevels",          bus_property_append_string, "s", s->sysv_runlevels             },
+                { "org.freedesktop.systemd1.Service", "SysVStartPriority",      bus_property_append_int,    "i", &s->sysv_start_priority       },
+                { "org.freedesktop.systemd1.Service", "SysVPath",               bus_property_append_string, "s", s->sysv_path                  },
 #endif
-                { "org.freedesktop.systemd1.Service", "FsckPassNo",             bus_property_append_int,    "i", &u->service.fsck_passno               },
+                { "org.freedesktop.systemd1.Service", "FsckPassNo",             bus_property_append_int,    "i", &s->fsck_passno               },
                 { NULL, NULL, NULL, NULL, NULL }
         };
 
diff --git a/src/dbus-snapshot.c b/src/dbus-snapshot.c
index 0c2f349..0967034 100644
--- a/src/dbus-snapshot.c
+++ b/src/dbus-snapshot.c
@@ -46,10 +46,10 @@
 const char bus_snapshot_interface[] _introspect_("Snapshot") = BUS_SNAPSHOT_INTERFACE;
 
 DBusHandlerResult bus_snapshot_message_handler(Unit *u, DBusConnection *c, DBusMessage *message) {
-
+        Snapshot *s = SNAPSHOT(u);
         const BusProperty properties[] = {
                 BUS_UNIT_PROPERTIES,
-                { "org.freedesktop.systemd1.Snapshot", "Cleanup", bus_property_append_bool, "b", &u->snapshot.cleanup },
+                { "org.freedesktop.systemd1.Snapshot", "Cleanup", bus_property_append_bool, "b", &s->cleanup },
                 { NULL, NULL, NULL, NULL, NULL }
         };
 
diff --git a/src/dbus-socket.c b/src/dbus-socket.c
index c428189..9caed55 100644
--- a/src/dbus-socket.c
+++ b/src/dbus-socket.c
@@ -88,39 +88,39 @@ const char bus_socket_invalidating_properties[] =
 static DEFINE_BUS_PROPERTY_APPEND_ENUM(bus_socket_append_bind_ipv6_only, socket_address_bind_ipv6_only, SocketAddressBindIPv6Only);
 
 DBusHandlerResult bus_socket_message_handler(Unit *u, DBusConnection *c, DBusMessage *message) {
-
+        Socket *s = SOCKET(u);
         const BusProperty properties[] = {
                 BUS_UNIT_PROPERTIES,
-                { "org.freedesktop.systemd1.Socket", "BindIPv6Only",   bus_socket_append_bind_ipv6_only, "s", &u->socket.bind_ipv6_only  },
-                { "org.freedesktop.systemd1.Socket", "Backlog",        bus_property_append_unsigned,     "u", &u->socket.backlog         },
-                { "org.freedesktop.systemd1.Socket", "TimeoutUSec",    bus_property_append_usec,         "t", &u->socket.timeout_usec    },
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Socket", u->service.exec_command[SOCKET_EXEC_START_PRE],  "ExecStartPre"),
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Socket", u->service.exec_command[SOCKET_EXEC_START_POST], "ExecStartPost"),
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Socket", u->service.exec_command[SOCKET_EXEC_STOP_PRE],   "ExecStopPre"),
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Socket", u->service.exec_command[SOCKET_EXEC_STOP_POST],  "ExecStopPost"),
-                BUS_EXEC_CONTEXT_PROPERTIES("org.freedesktop.systemd1.Socket", u->socket.exec_context),
-                { "org.freedesktop.systemd1.Socket", "ControlPID",     bus_property_append_pid,          "u", &u->socket.control_pid     },
-                { "org.freedesktop.systemd1.Socket", "BindToDevice",   bus_property_append_string,       "s", u->socket.bind_to_device   },
-                { "org.freedesktop.systemd1.Socket", "DirectoryMode",  bus_property_append_mode,         "u", &u->socket.directory_mode  },
-                { "org.freedesktop.systemd1.Socket", "SocketMode",     bus_property_append_mode,         "u", &u->socket.socket_mode     },
-                { "org.freedesktop.systemd1.Socket", "Accept",         bus_property_append_bool,         "b", &u->socket.accept          },
-                { "org.freedesktop.systemd1.Socket", "KeepAlive",      bus_property_append_bool,         "b", &u->socket.keep_alive      },
-                { "org.freedesktop.systemd1.Socket", "Priority",       bus_property_append_int,          "i", &u->socket.priority        },
-                { "org.freedesktop.systemd1.Socket", "ReceiveBuffer",  bus_property_append_size,         "t", &u->socket.receive_buffer  },
-                { "org.freedesktop.systemd1.Socket", "SendBuffer",     bus_property_append_size,         "t", &u->socket.send_buffer     },
-                { "org.freedesktop.systemd1.Socket", "IPTOS",          bus_property_append_int,          "i", &u->socket.ip_tos          },
-                { "org.freedesktop.systemd1.Socket", "IPTTL",          bus_property_append_int,          "i", &u->socket.ip_ttl          },
-                { "org.freedesktop.systemd1.Socket", "PipeSize",       bus_property_append_size,         "t", &u->socket.pipe_size       },
-                { "org.freedesktop.systemd1.Socket", "FreeBind",       bus_property_append_bool,         "b", &u->socket.free_bind       },
-                { "org.freedesktop.systemd1.Socket", "Transparent",    bus_property_append_bool,         "b", &u->socket.transparent     },
-                { "org.freedesktop.systemd1.Socket", "Broadcast",      bus_property_append_bool,         "b", &u->socket.broadcast       },
-                { "org.freedesktop.systemd1.Socket", "PassCredentials",bus_property_append_bool,         "b", &u->socket.pass_cred       },
-                { "org.freedesktop.systemd1.Socket", "Mark",           bus_property_append_int,          "i", &u->socket.mark            },
-                { "org.freedesktop.systemd1.Socket", "MaxConnections", bus_property_append_unsigned,     "u", &u->socket.max_connections },
-                { "org.freedesktop.systemd1.Socket", "NConnections",   bus_property_append_unsigned,     "u", &u->socket.n_connections   },
-                { "org.freedesktop.systemd1.Socket", "NAccepted",      bus_property_append_unsigned,     "u", &u->socket.n_accepted      },
-                { "org.freedesktop.systemd1.Socket", "MessageQueueMaxMessages", bus_property_append_long,"x", &u->socket.mq_maxmsg       },
-                { "org.freedesktop.systemd1.Socket", "MessageQueueMessageSize", bus_property_append_long,"x", &u->socket.mq_msgsize      },
+                { "org.freedesktop.systemd1.Socket", "BindIPv6Only",   bus_socket_append_bind_ipv6_only, "s", &s->bind_ipv6_only  },
+                { "org.freedesktop.systemd1.Socket", "Backlog",        bus_property_append_unsigned,     "u", &s->backlog         },
+                { "org.freedesktop.systemd1.Socket", "TimeoutUSec",    bus_property_append_usec,         "t", &s->timeout_usec    },
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Socket", s->exec_command[SOCKET_EXEC_START_PRE],  "ExecStartPre"),
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Socket", s->exec_command[SOCKET_EXEC_START_POST], "ExecStartPost"),
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Socket", s->exec_command[SOCKET_EXEC_STOP_PRE],   "ExecStopPre"),
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Socket", s->exec_command[SOCKET_EXEC_STOP_POST],  "ExecStopPost"),
+                BUS_EXEC_CONTEXT_PROPERTIES("org.freedesktop.systemd1.Socket", s->exec_context),
+                { "org.freedesktop.systemd1.Socket", "ControlPID",     bus_property_append_pid,          "u", &s->control_pid     },
+                { "org.freedesktop.systemd1.Socket", "BindToDevice",   bus_property_append_string,       "s", s->bind_to_device   },
+                { "org.freedesktop.systemd1.Socket", "DirectoryMode",  bus_property_append_mode,         "u", &s->directory_mode  },
+                { "org.freedesktop.systemd1.Socket", "SocketMode",     bus_property_append_mode,         "u", &s->socket_mode     },
+                { "org.freedesktop.systemd1.Socket", "Accept",         bus_property_append_bool,         "b", &s->accept          },
+                { "org.freedesktop.systemd1.Socket", "KeepAlive",      bus_property_append_bool,         "b", &s->keep_alive      },
+                { "org.freedesktop.systemd1.Socket", "Priority",       bus_property_append_int,          "i", &s->priority        },
+                { "org.freedesktop.systemd1.Socket", "ReceiveBuffer",  bus_property_append_size,         "t", &s->receive_buffer  },
+                { "org.freedesktop.systemd1.Socket", "SendBuffer",     bus_property_append_size,         "t", &s->send_buffer     },
+                { "org.freedesktop.systemd1.Socket", "IPTOS",          bus_property_append_int,          "i", &s->ip_tos          },
+                { "org.freedesktop.systemd1.Socket", "IPTTL",          bus_property_append_int,          "i", &s->ip_ttl          },
+                { "org.freedesktop.systemd1.Socket", "PipeSize",       bus_property_append_size,         "t", &s->pipe_size       },
+                { "org.freedesktop.systemd1.Socket", "FreeBind",       bus_property_append_bool,         "b", &s->free_bind       },
+                { "org.freedesktop.systemd1.Socket", "Transparent",    bus_property_append_bool,         "b", &s->transparent     },
+                { "org.freedesktop.systemd1.Socket", "Broadcast",      bus_property_append_bool,         "b", &s->broadcast       },
+                { "org.freedesktop.systemd1.Socket", "PassCredentials",bus_property_append_bool,         "b", &s->pass_cred       },
+                { "org.freedesktop.systemd1.Socket", "Mark",           bus_property_append_int,          "i", &s->mark            },
+                { "org.freedesktop.systemd1.Socket", "MaxConnections", bus_property_append_unsigned,     "u", &s->max_connections },
+                { "org.freedesktop.systemd1.Socket", "NConnections",   bus_property_append_unsigned,     "u", &s->n_connections   },
+                { "org.freedesktop.systemd1.Socket", "NAccepted",      bus_property_append_unsigned,     "u", &s->n_accepted      },
+                { "org.freedesktop.systemd1.Socket", "MessageQueueMaxMessages", bus_property_append_long,"x", &s->mq_maxmsg       },
+                { "org.freedesktop.systemd1.Socket", "MessageQueueMessageSize", bus_property_append_long,"x", &s->mq_msgsize      },
                 { NULL, NULL, NULL, NULL, NULL }
         };
 
diff --git a/src/dbus-swap.c b/src/dbus-swap.c
index 988ca58..3002581 100644
--- a/src/dbus-swap.c
+++ b/src/dbus-swap.c
@@ -85,14 +85,15 @@ static int bus_swap_append_priority(DBusMessageIter *i, const char *property, vo
 }
 
 DBusHandlerResult bus_swap_message_handler(Unit *u, DBusConnection *c, DBusMessage *message) {
+        Swap *s = SWAP(u);
         const BusProperty properties[] = {
                 BUS_UNIT_PROPERTIES,
-                { "org.freedesktop.systemd1.Swap", "What",       bus_property_append_string, "s", u->swap.what          },
-                { "org.freedesktop.systemd1.Swap", "Priority",   bus_swap_append_priority,   "i", u                     },
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Swap", u->swap.exec_command+SWAP_EXEC_ACTIVATE,   "ExecActivate"),
-                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Swap", u->swap.exec_command+SWAP_EXEC_DEACTIVATE, "ExecDeactivate"),
-                BUS_EXEC_CONTEXT_PROPERTIES("org.freedesktop.systemd1.Swap", u->swap.exec_context),
-                { "org.freedesktop.systemd1.Swap", "ControlPID", bus_property_append_pid,    "u", &u->swap.control_pid },
+                { "org.freedesktop.systemd1.Swap", "What",       bus_property_append_string, "s", s->what         },
+                { "org.freedesktop.systemd1.Swap", "Priority",   bus_swap_append_priority,   "i", u               },
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Swap", s->exec_command+SWAP_EXEC_ACTIVATE,   "ExecActivate"),
+                BUS_EXEC_COMMAND_PROPERTY("org.freedesktop.systemd1.Swap", s->exec_command+SWAP_EXEC_DEACTIVATE, "ExecDeactivate"),
+                BUS_EXEC_CONTEXT_PROPERTIES("org.freedesktop.systemd1.Swap", s->exec_context),
+                { "org.freedesktop.systemd1.Swap", "ControlPID", bus_property_append_pid,    "u", &s->control_pid },
                 { NULL, NULL, NULL, NULL, NULL }
         };
 
diff --git a/src/dbus-timer.c b/src/dbus-timer.c
index 07d425e..0c4b4f3 100644
--- a/src/dbus-timer.c
+++ b/src/dbus-timer.c
@@ -101,23 +101,25 @@ static int bus_timer_append_timers(DBusMessageIter *i, const char *property, voi
 
 static int bus_timer_append_unit(DBusMessageIter *i, const char *property, void *data) {
         Unit *u = data;
+        Timer *timer = TIMER(u);
         const char *t;
 
         assert(i);
         assert(property);
         assert(u);
 
-        t = UNIT_DEREF(u->timer.unit) ? UNIT_DEREF(u->timer.unit)->meta.id : "";
+        t = UNIT_DEREF(timer->unit) ? UNIT_DEREF(timer->unit)->id : "";
 
         return dbus_message_iter_append_basic(i, DBUS_TYPE_STRING, &t) ? 0 : -ENOMEM;
 }
 
 DBusHandlerResult bus_timer_message_handler(Unit *u, DBusConnection *c, DBusMessage *message) {
+        Timer *t = TIMER(u);
         const BusProperty properties[] = {
                 BUS_UNIT_PROPERTIES,
-                { "org.freedesktop.systemd1.Timer", "Unit",           bus_timer_append_unit,      "s",      u                      },
-                { "org.freedesktop.systemd1.Timer", "Timers",         bus_timer_append_timers,    "a(stt)", u                      },
-                { "org.freedesktop.systemd1.Timer", "NextElapseUSec", bus_property_append_usec,   "t",      &u->timer.next_elapse  },
+                { "org.freedesktop.systemd1.Timer", "Unit",           bus_timer_append_unit,      "s",      u               },
+                { "org.freedesktop.systemd1.Timer", "Timers",         bus_timer_append_timers,    "a(stt)", u               },
+                { "org.freedesktop.systemd1.Timer", "NextElapseUSec", bus_property_append_usec,   "t",      &t->next_elapse },
                 { NULL, NULL, NULL, NULL, NULL }
         };
 
diff --git a/src/dbus-unit.c b/src/dbus-unit.c
index 611a120..dc5321e 100644
--- a/src/dbus-unit.c
+++ b/src/dbus-unit.c
@@ -49,7 +49,7 @@ int bus_unit_append_names(DBusMessageIter *i, const char *property, void *data)
         if (!dbus_message_iter_open_container(i, DBUS_TYPE_ARRAY, "s", &sub))
                 return -ENOMEM;
 
-        SET_FOREACH(t, u->meta.names, j)
+        SET_FOREACH(t, u->names, j)
                 if (!dbus_message_iter_append_basic(&sub, DBUS_TYPE_STRING, &t))
                         return -ENOMEM;
 
@@ -68,7 +68,7 @@ int bus_unit_append_following(DBusMessageIter *i, const char *property, void *da
         assert(u);
 
         f = unit_following(u);
-        d = f ? f->meta.id : "";
+        d = f ? f->id : "";
 
         if (!dbus_message_iter_append_basic(i, DBUS_TYPE_STRING, &d))
                 return -ENOMEM;
@@ -86,7 +86,7 @@ int bus_unit_append_dependencies(DBusMessageIter *i, const char *property, void
                 return -ENOMEM;
 
         SET_FOREACH(u, s, j)
-                if (!dbus_message_iter_append_basic(&sub, DBUS_TYPE_STRING, &u->meta.id))
+                if (!dbus_message_iter_append_basic(&sub, DBUS_TYPE_STRING, &u->id))
                         return -ENOMEM;
 
         if (!dbus_message_iter_close_container(i, &sub))
@@ -170,7 +170,7 @@ int bus_unit_append_can_start(DBusMessageIter *i, const char *property, void *da
         assert(u);
 
         b = unit_can_start(u) &&
-                !u->meta.refuse_manual_start;
+                !u->refuse_manual_start;
 
         if (!dbus_message_iter_append_basic(i, DBUS_TYPE_BOOLEAN, &b))
                 return -ENOMEM;
@@ -190,7 +190,7 @@ int bus_unit_append_can_stop(DBusMessageIter *i, const char *property, void *dat
          * we can also stop */
 
         b = unit_can_start(u) &&
-                !u->meta.refuse_manual_stop;
+                !u->refuse_manual_stop;
 
         if (!dbus_message_iter_append_basic(i, DBUS_TYPE_BOOLEAN, &b))
                 return -ENOMEM;
@@ -223,7 +223,7 @@ int bus_unit_append_can_isolate(DBusMessageIter *i, const char *property, void *
         assert(u);
 
         b = unit_can_isolate(u) &&
-                !u->meta.refuse_manual_start;
+                !u->refuse_manual_start;
 
         if (!dbus_message_iter_append_basic(i, DBUS_TYPE_BOOLEAN, &b))
                 return -ENOMEM;
@@ -243,12 +243,12 @@ int bus_unit_append_job(DBusMessageIter *i, const char *property, void *data) {
         if (!dbus_message_iter_open_container(i, DBUS_TYPE_STRUCT, NULL, &sub))
                 return -ENOMEM;
 
-        if (u->meta.job) {
+        if (u->job) {
 
-                if (!(p = job_dbus_path(u->meta.job)))
+                if (!(p = job_dbus_path(u->job)))
                         return -ENOMEM;
 
-                if (!dbus_message_iter_append_basic(&sub, DBUS_TYPE_UINT32, &u->meta.job->id) ||
+                if (!dbus_message_iter_append_basic(&sub, DBUS_TYPE_UINT32, &u->job->id) ||
                     !dbus_message_iter_append_basic(&sub, DBUS_TYPE_OBJECT_PATH, &p)) {
                         free(p);
                         return -ENOMEM;
@@ -310,7 +310,7 @@ int bus_unit_append_cgroups(DBusMessageIter *i, const char *property, void *data
         if (!dbus_message_iter_open_container(i, DBUS_TYPE_ARRAY, "s", &sub))
                 return -ENOMEM;
 
-        LIST_FOREACH(by_unit, cgb, u->meta.cgroup_bondings) {
+        LIST_FOREACH(by_unit, cgb, u->cgroup_bondings) {
                 char *t;
                 bool success;
 
@@ -338,7 +338,7 @@ int bus_unit_append_cgroup_attrs(DBusMessageIter *i, const char *property, void
         if (!dbus_message_iter_open_container(i, DBUS_TYPE_ARRAY, "(sss)", &sub))
                 return -ENOMEM;
 
-        LIST_FOREACH(by_unit, a, u->meta.cgroup_attributes) {
+        LIST_FOREACH(by_unit, a, u->cgroup_attributes) {
                 char *v = NULL;
                 bool success;
 
@@ -389,9 +389,9 @@ int bus_unit_append_load_error(DBusMessageIter *i, const char *property, void *d
         assert(property);
         assert(u);
 
-        if (u->meta.load_error != 0) {
-                name = bus_errno_to_dbus(u->meta.load_error);
-                message = strempty(strerror(-u->meta.load_error));
+        if (u->load_error != 0) {
+                name = bus_errno_to_dbus(u->load_error);
+                message = strempty(strerror(-u->load_error));
         } else
                 name = message = "";
 
@@ -406,7 +406,7 @@ int bus_unit_append_load_error(DBusMessageIter *i, const char *property, void *d
 
 static DBusHandlerResult bus_unit_message_dispatch(Unit *u, DBusConnection *connection, DBusMessage *message) {
         DBusMessage *reply = NULL;
-        Manager *m = u->meta.manager;
+        Manager *m = u->manager;
         DBusError error;
         JobType job_type = _JOB_TYPE_INVALID;
         char *path = NULL;
@@ -489,10 +489,10 @@ static DBusHandlerResult bus_unit_message_dispatch(Unit *u, DBusConnection *conn
                 Job *j;
                 int r;
 
-                if ((job_type == JOB_START && u->meta.refuse_manual_start) ||
-                    (job_type == JOB_STOP && u->meta.refuse_manual_stop) ||
+                if ((job_type == JOB_START && u->refuse_manual_start) ||
+                    (job_type == JOB_STOP && u->refuse_manual_stop) ||
                     ((job_type == JOB_RESTART || job_type == JOB_TRY_RESTART) &&
-                     (u->meta.refuse_manual_start || u->meta.refuse_manual_stop))) {
+                     (u->refuse_manual_start || u->refuse_manual_stop))) {
                         dbus_set_error(&error, BUS_ERROR_ONLY_BY_DEPENDENCY, "Operation refused, may be requested by dependency only.");
                         return bus_send_error_reply(connection, message, &error, -EPERM);
                 }
@@ -594,7 +594,7 @@ static DBusHandlerResult bus_unit_message_handler(DBusConnection *connection, DB
                         HASHMAP_FOREACH_KEY(u, k, m->units, i) {
                                 char *p;
 
-                                if (k != u->meta.id)
+                                if (k != u->id)
                                         continue;
 
                                 if (!(p = bus_path_escape(k))) {
@@ -673,23 +673,23 @@ void bus_unit_send_change_signal(Unit *u) {
 
         assert(u);
 
-        if (u->meta.in_dbus_queue) {
-                LIST_REMOVE(Meta, dbus_queue, u->meta.manager->dbus_unit_queue, &u->meta);
-                u->meta.in_dbus_queue = false;
+        if (u->in_dbus_queue) {
+                LIST_REMOVE(Unit, dbus_queue, u->manager->dbus_unit_queue, u);
+                u->in_dbus_queue = false;
         }
 
-        if (!u->meta.id)
+        if (!u->id)
                 return;
 
-        if (!bus_has_subscriber(u->meta.manager)) {
-                u->meta.sent_dbus_new_signal = true;
+        if (!bus_has_subscriber(u->manager)) {
+                u->sent_dbus_new_signal = true;
                 return;
         }
 
         if (!(p = unit_dbus_path(u)))
                 goto oom;
 
-        if (u->meta.sent_dbus_new_signal) {
+        if (u->sent_dbus_new_signal) {
                 /* Send a properties changed signal. First for the
                  * specific type, then for the generic unit. The
                  * clients may rely on this order to get atomic
@@ -702,7 +702,7 @@ void bus_unit_send_change_signal(Unit *u) {
                                                              UNIT_VTABLE(u)->bus_invalidating_properties)))
                                 goto oom;
 
-                        if (bus_broadcast(u->meta.manager, m) < 0)
+                        if (bus_broadcast(u->manager, m) < 0)
                                 goto oom;
 
                         dbus_message_unref(m);
@@ -718,19 +718,19 @@ void bus_unit_send_change_signal(Unit *u) {
                         goto oom;
 
                 if (!dbus_message_append_args(m,
-                                              DBUS_TYPE_STRING, &u->meta.id,
+                                              DBUS_TYPE_STRING, &u->id,
                                               DBUS_TYPE_OBJECT_PATH, &p,
                                               DBUS_TYPE_INVALID))
                         goto oom;
         }
 
-        if (bus_broadcast(u->meta.manager, m) < 0)
+        if (bus_broadcast(u->manager, m) < 0)
                 goto oom;
 
         free(p);
         dbus_message_unref(m);
 
-        u->meta.sent_dbus_new_signal = true;
+        u->sent_dbus_new_signal = true;
 
         return;
 
@@ -749,13 +749,13 @@ void bus_unit_send_removed_signal(Unit *u) {
 
         assert(u);
 
-        if (!bus_has_subscriber(u->meta.manager))
+        if (!bus_has_subscriber(u->manager))
                 return;
 
-        if (!u->meta.sent_dbus_new_signal)
+        if (!u->sent_dbus_new_signal)
                 bus_unit_send_change_signal(u);
 
-        if (!u->meta.id)
+        if (!u->id)
                 return;
 
         if (!(p = unit_dbus_path(u)))
@@ -765,12 +765,12 @@ void bus_unit_send_removed_signal(Unit *u) {
                 goto oom;
 
         if (!dbus_message_append_args(m,
-                                      DBUS_TYPE_STRING, &u->meta.id,
+                                      DBUS_TYPE_STRING, &u->id,
                                       DBUS_TYPE_OBJECT_PATH, &p,
                                       DBUS_TYPE_INVALID))
                 goto oom;
 
-        if (bus_broadcast(u->meta.manager, m) < 0)
+        if (bus_broadcast(u->manager, m) < 0)
                 goto oom;
 
         free(p);
diff --git a/src/dbus-unit.h b/src/dbus-unit.h
index 7a43410..6476c8a 100644
--- a/src/dbus-unit.h
+++ b/src/dbus-unit.h
@@ -127,63 +127,63 @@
         "org.freedesktop.systemd1.Unit\0"
 
 #define BUS_UNIT_PROPERTIES \
-        { "org.freedesktop.systemd1.Unit", "Id",                   bus_property_append_string,     "s",    u->meta.id                        }, \
+        { "org.freedesktop.systemd1.Unit", "Id",                   bus_property_append_string,     "s",    u->id                        }, \
         { "org.freedesktop.systemd1.Unit", "Names",                bus_unit_append_names,          "as",   u                                 }, \
         { "org.freedesktop.systemd1.Unit", "Following",            bus_unit_append_following,      "s",    u                                 }, \
-        { "org.freedesktop.systemd1.Unit", "Requires",             bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_REQUIRES] }, \
-        { "org.freedesktop.systemd1.Unit", "RequiresOverridable",  bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_REQUIRES_OVERRIDABLE] }, \
-        { "org.freedesktop.systemd1.Unit", "Requisite",            bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_REQUISITE] }, \
-        { "org.freedesktop.systemd1.Unit", "RequisiteOverridable", bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_REQUISITE_OVERRIDABLE] }, \
-        { "org.freedesktop.systemd1.Unit", "Wants",                bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_WANTS]  }, \
-        { "org.freedesktop.systemd1.Unit", "BindTo",               bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_BIND_TO]  }, \
-        { "org.freedesktop.systemd1.Unit", "RequiredBy",           bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_REQUIRED_BY] }, \
-        { "org.freedesktop.systemd1.Unit", "RequiredByOverridable",bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_REQUIRED_BY_OVERRIDABLE] }, \
-        { "org.freedesktop.systemd1.Unit", "WantedBy",             bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_WANTED_BY] }, \
-        { "org.freedesktop.systemd1.Unit", "BoundBy",              bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_BOUND_BY]  }, \
-        { "org.freedesktop.systemd1.Unit", "Conflicts",            bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_CONFLICTS] }, \
-        { "org.freedesktop.systemd1.Unit", "ConflictedBy",         bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_CONFLICTED_BY] }, \
-        { "org.freedesktop.systemd1.Unit", "Before",               bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_BEFORE] }, \
-        { "org.freedesktop.systemd1.Unit", "After",                bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_AFTER]  }, \
-        { "org.freedesktop.systemd1.Unit", "OnFailure",            bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_ON_FAILURE] }, \
-        { "org.freedesktop.systemd1.Unit", "Triggers",             bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_TRIGGERS] }, \
-        { "org.freedesktop.systemd1.Unit", "TriggeredBy",          bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_TRIGGERED_BY] }, \
-        { "org.freedesktop.systemd1.Unit", "PropagateReloadTo",    bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_PROPAGATE_RELOAD_TO] }, \
-        { "org.freedesktop.systemd1.Unit", "PropagateReloadFrom",  bus_unit_append_dependencies,   "as",   u->meta.dependencies[UNIT_PROPAGATE_RELOAD_FROM] }, \
+        { "org.freedesktop.systemd1.Unit", "Requires",             bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_REQUIRES] }, \
+        { "org.freedesktop.systemd1.Unit", "RequiresOverridable",  bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_REQUIRES_OVERRIDABLE] }, \
+        { "org.freedesktop.systemd1.Unit", "Requisite",            bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_REQUISITE] }, \
+        { "org.freedesktop.systemd1.Unit", "RequisiteOverridable", bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_REQUISITE_OVERRIDABLE] }, \
+        { "org.freedesktop.systemd1.Unit", "Wants",                bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_WANTS]  }, \
+        { "org.freedesktop.systemd1.Unit", "BindTo",               bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_BIND_TO]  }, \
+        { "org.freedesktop.systemd1.Unit", "RequiredBy",           bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_REQUIRED_BY] }, \
+        { "org.freedesktop.systemd1.Unit", "RequiredByOverridable",bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_REQUIRED_BY_OVERRIDABLE] }, \
+        { "org.freedesktop.systemd1.Unit", "WantedBy",             bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_WANTED_BY] }, \
+        { "org.freedesktop.systemd1.Unit", "BoundBy",              bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_BOUND_BY]  }, \
+        { "org.freedesktop.systemd1.Unit", "Conflicts",            bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_CONFLICTS] }, \
+        { "org.freedesktop.systemd1.Unit", "ConflictedBy",         bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_CONFLICTED_BY] }, \
+        { "org.freedesktop.systemd1.Unit", "Before",               bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_BEFORE] }, \
+        { "org.freedesktop.systemd1.Unit", "After",                bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_AFTER]  }, \
+        { "org.freedesktop.systemd1.Unit", "OnFailure",            bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_ON_FAILURE] }, \
+        { "org.freedesktop.systemd1.Unit", "Triggers",             bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_TRIGGERS] }, \
+        { "org.freedesktop.systemd1.Unit", "TriggeredBy",          bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_TRIGGERED_BY] }, \
+        { "org.freedesktop.systemd1.Unit", "PropagateReloadTo",    bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_PROPAGATE_RELOAD_TO] }, \
+        { "org.freedesktop.systemd1.Unit", "PropagateReloadFrom",  bus_unit_append_dependencies,   "as",   u->dependencies[UNIT_PROPAGATE_RELOAD_FROM] }, \
         { "org.freedesktop.systemd1.Unit", "Description",          bus_unit_append_description,    "s",    u                                 }, \
-        { "org.freedesktop.systemd1.Unit", "LoadState",            bus_unit_append_load_state,     "s",    &u->meta.load_state               }, \
+        { "org.freedesktop.systemd1.Unit", "LoadState",            bus_unit_append_load_state,     "s",    &u->load_state               }, \
         { "org.freedesktop.systemd1.Unit", "ActiveState",          bus_unit_append_active_state,   "s",    u                                 }, \
         { "org.freedesktop.systemd1.Unit", "SubState",             bus_unit_append_sub_state,      "s",    u                                 }, \
-        { "org.freedesktop.systemd1.Unit", "FragmentPath",         bus_property_append_string,     "s",    u->meta.fragment_path             }, \
+        { "org.freedesktop.systemd1.Unit", "FragmentPath",         bus_property_append_string,     "s",    u->fragment_path             }, \
         { "org.freedesktop.systemd1.Unit", "UnitFileState",        bus_unit_append_file_state,     "s",    u                                 }, \
-        { "org.freedesktop.systemd1.Unit", "InactiveExitTimestamp",bus_property_append_usec,       "t",    &u->meta.inactive_exit_timestamp.realtime }, \
-        { "org.freedesktop.systemd1.Unit", "InactiveExitTimestampMonotonic",bus_property_append_usec, "t", &u->meta.inactive_exit_timestamp.monotonic }, \
-        { "org.freedesktop.systemd1.Unit", "ActiveEnterTimestamp", bus_property_append_usec,       "t",    &u->meta.active_enter_timestamp.realtime }, \
-        { "org.freedesktop.systemd1.Unit", "ActiveEnterTimestampMonotonic", bus_property_append_usec, "t", &u->meta.active_enter_timestamp.monotonic }, \
-        { "org.freedesktop.systemd1.Unit", "ActiveExitTimestamp",  bus_property_append_usec,       "t",    &u->meta.active_exit_timestamp.realtime }, \
-        { "org.freedesktop.systemd1.Unit", "ActiveExitTimestampMonotonic",  bus_property_append_usec, "t", &u->meta.active_exit_timestamp.monotonic }, \
-        { "org.freedesktop.systemd1.Unit", "InactiveEnterTimestamp",bus_property_append_usec,      "t",    &u->meta.inactive_enter_timestamp.realtime }, \
-        { "org.freedesktop.systemd1.Unit", "InactiveEnterTimestampMonotonic",bus_property_append_usec,"t", &u->meta.inactive_enter_timestamp.monotonic }, \
+        { "org.freedesktop.systemd1.Unit", "InactiveExitTimestamp",bus_property_append_usec,       "t",    &u->inactive_exit_timestamp.realtime }, \
+        { "org.freedesktop.systemd1.Unit", "InactiveExitTimestampMonotonic",bus_property_append_usec, "t", &u->inactive_exit_timestamp.monotonic }, \
+        { "org.freedesktop.systemd1.Unit", "ActiveEnterTimestamp", bus_property_append_usec,       "t",    &u->active_enter_timestamp.realtime }, \
+        { "org.freedesktop.systemd1.Unit", "ActiveEnterTimestampMonotonic", bus_property_append_usec, "t", &u->active_enter_timestamp.monotonic }, \
+        { "org.freedesktop.systemd1.Unit", "ActiveExitTimestamp",  bus_property_append_usec,       "t",    &u->active_exit_timestamp.realtime }, \
+        { "org.freedesktop.systemd1.Unit", "ActiveExitTimestampMonotonic",  bus_property_append_usec, "t", &u->active_exit_timestamp.monotonic }, \
+        { "org.freedesktop.systemd1.Unit", "InactiveEnterTimestamp",bus_property_append_usec,      "t",    &u->inactive_enter_timestamp.realtime }, \
+        { "org.freedesktop.systemd1.Unit", "InactiveEnterTimestampMonotonic",bus_property_append_usec,"t", &u->inactive_enter_timestamp.monotonic }, \
         { "org.freedesktop.systemd1.Unit", "CanStart",             bus_unit_append_can_start,      "b",    u                                 }, \
         { "org.freedesktop.systemd1.Unit", "CanStop",              bus_unit_append_can_stop,       "b",    u                                 }, \
         { "org.freedesktop.systemd1.Unit", "CanReload",            bus_unit_append_can_reload,     "b",    u                                 }, \
         { "org.freedesktop.systemd1.Unit", "CanIsolate",           bus_unit_append_can_isolate,    "b",    u                                 }, \
         { "org.freedesktop.systemd1.Unit", "Job",                  bus_unit_append_job,            "(uo)", u                                 }, \
-        { "org.freedesktop.systemd1.Unit", "StopWhenUnneeded",     bus_property_append_bool,       "b",    &u->meta.stop_when_unneeded       }, \
-        { "org.freedesktop.systemd1.Unit", "RefuseManualStart",    bus_property_append_bool,       "b",    &u->meta.refuse_manual_start      }, \
-        { "org.freedesktop.systemd1.Unit", "RefuseManualStop",     bus_property_append_bool,       "b",    &u->meta.refuse_manual_stop       }, \
-        { "org.freedesktop.systemd1.Unit", "AllowIsolate",         bus_property_append_bool,       "b",    &u->meta.allow_isolate            }, \
-        { "org.freedesktop.systemd1.Unit", "DefaultDependencies",  bus_property_append_bool,       "b",    &u->meta.default_dependencies     }, \
-        { "org.freedesktop.systemd1.Unit", "OnFailureIsolate",     bus_property_append_bool,       "b",    &u->meta.on_failure_isolate       }, \
-        { "org.freedesktop.systemd1.Unit", "IgnoreOnIsolate",      bus_property_append_bool,       "b",    &u->meta.ignore_on_isolate        }, \
-        { "org.freedesktop.systemd1.Unit", "IgnoreOnSnapshot",     bus_property_append_bool,       "b",    &u->meta.ignore_on_snapshot       }, \
+        { "org.freedesktop.systemd1.Unit", "StopWhenUnneeded",     bus_property_append_bool,       "b",    &u->stop_when_unneeded       }, \
+        { "org.freedesktop.systemd1.Unit", "RefuseManualStart",    bus_property_append_bool,       "b",    &u->refuse_manual_start      }, \
+        { "org.freedesktop.systemd1.Unit", "RefuseManualStop",     bus_property_append_bool,       "b",    &u->refuse_manual_stop       }, \
+        { "org.freedesktop.systemd1.Unit", "AllowIsolate",         bus_property_append_bool,       "b",    &u->allow_isolate            }, \
+        { "org.freedesktop.systemd1.Unit", "DefaultDependencies",  bus_property_append_bool,       "b",    &u->default_dependencies     }, \
+        { "org.freedesktop.systemd1.Unit", "OnFailureIsolate",     bus_property_append_bool,       "b",    &u->on_failure_isolate       }, \
+        { "org.freedesktop.systemd1.Unit", "IgnoreOnIsolate",      bus_property_append_bool,       "b",    &u->ignore_on_isolate        }, \
+        { "org.freedesktop.systemd1.Unit", "IgnoreOnSnapshot",     bus_property_append_bool,       "b",    &u->ignore_on_snapshot       }, \
         { "org.freedesktop.systemd1.Unit", "DefaultControlGroup",  bus_unit_append_default_cgroup, "s",    u                                 }, \
         { "org.freedesktop.systemd1.Unit", "ControlGroup",         bus_unit_append_cgroups,        "as",   u                                 }, \
         { "org.freedesktop.systemd1.Unit", "ControlGroupAttributes", bus_unit_append_cgroup_attrs, "a(sss)", u                               }, \
         { "org.freedesktop.systemd1.Unit", "NeedDaemonReload",     bus_unit_append_need_daemon_reload, "b", u                                }, \
-        { "org.freedesktop.systemd1.Unit", "JobTimeoutUSec",       bus_property_append_usec,       "t",    &u->meta.job_timeout              }, \
-        { "org.freedesktop.systemd1.Unit", "ConditionTimestamp",   bus_property_append_usec,       "t",    &u->meta.condition_timestamp.realtime }, \
-        { "org.freedesktop.systemd1.Unit", "ConditionTimestampMonotonic", bus_property_append_usec,"t",    &u->meta.condition_timestamp.monotonic }, \
-        { "org.freedesktop.systemd1.Unit", "ConditionResult",      bus_property_append_bool,       "b",    &u->meta.condition_result         }, \
+        { "org.freedesktop.systemd1.Unit", "JobTimeoutUSec",       bus_property_append_usec,       "t",    &u->job_timeout              }, \
+        { "org.freedesktop.systemd1.Unit", "ConditionTimestamp",   bus_property_append_usec,       "t",    &u->condition_timestamp.realtime }, \
+        { "org.freedesktop.systemd1.Unit", "ConditionTimestampMonotonic", bus_property_append_usec,"t",    &u->condition_timestamp.monotonic }, \
+        { "org.freedesktop.systemd1.Unit", "ConditionResult",      bus_property_append_bool,       "b",    &u->condition_result         }, \
         { "org.freedesktop.systemd1.Unit", "LoadError",            bus_unit_append_load_error,     "(ss)", u                                 }
 
 int bus_unit_append_names(DBusMessageIter *i, const char *property, void *data);
diff --git a/src/dbus.c b/src/dbus.c
index f9250f1..8e6e9fd 100644
--- a/src/dbus.c
+++ b/src/dbus.c
@@ -370,7 +370,7 @@ static DBusHandlerResult api_bus_message_filter(DBusConnection *connection, DBus
                         } else {
                                 r = manager_load_unit(m, name, NULL, &error, &u);
 
-                                if (r >= 0 && u->meta.refuse_manual_start)
+                                if (r >= 0 && u->refuse_manual_start)
                                         r = -EPERM;
 
                                 if (r >= 0)
diff --git a/src/device.c b/src/device.c
index 64665a8..9e5bd30 100644
--- a/src/device.c
+++ b/src/device.c
@@ -389,7 +389,7 @@ static Unit *device_following(Unit *u) {
 
         assert(d);
 
-        if (startswith(u->meta.id, "sys-"))
+        if (startswith(u->id, "sys-"))
                 return NULL;
 
         /* Make everybody follow the unit that's named after the sysfs path */
diff --git a/src/device.h b/src/device.h
index 9a56a52..a05c3d3 100644
--- a/src/device.h
+++ b/src/device.h
@@ -36,7 +36,7 @@ typedef enum DeviceState {
 } DeviceState;
 
 struct Device {
-        Meta meta;
+        Unit meta;
 
         char *sysfs;
 
diff --git a/src/job.c b/src/job.c
index 1520d81..90fcd35 100644
--- a/src/job.c
+++ b/src/job.c
@@ -62,8 +62,8 @@ void job_free(Job *j) {
         if (j->installed) {
                 bus_job_send_removed_signal(j);
 
-                if (j->unit->meta.job == j) {
-                        j->unit->meta.job = NULL;
+                if (j->unit->job == j) {
+                        j->unit->job = NULL;
                         unit_add_to_gc_queue(j->unit);
                 }
 
@@ -147,7 +147,7 @@ void job_dump(Job *j, FILE*f, const char *prefix) {
                 "%s\tState: %s\n"
                 "%s\tForced: %s\n",
                 prefix, j->id,
-                prefix, j->unit->meta.id, job_type_to_string(j->type),
+                prefix, j->unit->id, job_type_to_string(j->type),
                 prefix, job_state_to_string(j->state),
                 prefix, yes_no(j->override));
 }
@@ -326,19 +326,19 @@ bool job_is_runnable(Job *j) {
                  * dependencies, regardless whether they are
                  * starting or stopping something. */
 
-                SET_FOREACH(other, j->unit->meta.dependencies[UNIT_AFTER], i)
-                        if (other->meta.job)
+                SET_FOREACH(other, j->unit->dependencies[UNIT_AFTER], i)
+                        if (other->job)
                                 return false;
         }
 
         /* Also, if something else is being stopped and we should
          * change state after it, then lets wait. */
 
-        SET_FOREACH(other, j->unit->meta.dependencies[UNIT_BEFORE], i)
-                if (other->meta.job &&
-                    (other->meta.job->type == JOB_STOP ||
-                     other->meta.job->type == JOB_RESTART ||
-                     other->meta.job->type == JOB_TRY_RESTART))
+        SET_FOREACH(other, j->unit->dependencies[UNIT_BEFORE], i)
+                if (other->job &&
+                    (other->job->type == JOB_STOP ||
+                     other->job->type == JOB_RESTART ||
+                     other->job->type == JOB_TRY_RESTART))
                         return false;
 
         /* This means that for a service a and a service b where b
@@ -489,7 +489,7 @@ static void job_print_status_message(Unit *u, JobType t, JobResult result) {
 
                 case JOB_FAILED:
                         unit_status_printf(u, ANSI_HIGHLIGHT_ON "FAILED" ANSI_HIGHLIGHT_OFF, "Failed to start %s", unit_description(u));
-                        unit_status_printf(u, NULL, "See 'systemctl status %s' for details.", u->meta.id);
+                        unit_status_printf(u, NULL, "See 'systemctl status %s' for details.", u->id);
                         break;
 
                 case JOB_DEPENDENCY:
@@ -539,8 +539,8 @@ int job_finish_and_invalidate(Job *j, JobResult result) {
         if (result == JOB_DONE && (j->type == JOB_RESTART || j->type == JOB_TRY_RESTART)) {
 
                 log_debug("Converting job %s/%s -> %s/%s",
-                          j->unit->meta.id, job_type_to_string(j->type),
-                          j->unit->meta.id, job_type_to_string(JOB_START));
+                          j->unit->id, job_type_to_string(j->type),
+                          j->unit->id, job_type_to_string(JOB_START));
 
                 j->state = JOB_WAITING;
                 j->type = JOB_START;
@@ -553,7 +553,7 @@ int job_finish_and_invalidate(Job *j, JobResult result) {
 
         j->result = result;
 
-        log_debug("Job %s/%s finished, result=%s", j->unit->meta.id, job_type_to_string(j->type), job_result_to_string(result));
+        log_debug("Job %s/%s finished, result=%s", j->unit->id, job_type_to_string(j->type), job_result_to_string(result));
 
         if (result == JOB_FAILED)
                 j->manager->n_failed_jobs ++;
@@ -571,42 +571,42 @@ int job_finish_and_invalidate(Job *j, JobResult result) {
                     t == JOB_VERIFY_ACTIVE ||
                     t == JOB_RELOAD_OR_START) {
 
-                        SET_FOREACH(other, u->meta.dependencies[UNIT_REQUIRED_BY], i)
-                                if (other->meta.job &&
-                                    (other->meta.job->type == JOB_START ||
-                                     other->meta.job->type == JOB_VERIFY_ACTIVE ||
-                                     other->meta.job->type == JOB_RELOAD_OR_START)) {
-                                        job_finish_and_invalidate(other->meta.job, JOB_DEPENDENCY);
+                        SET_FOREACH(other, u->dependencies[UNIT_REQUIRED_BY], i)
+                                if (other->job &&
+                                    (other->job->type == JOB_START ||
+                                     other->job->type == JOB_VERIFY_ACTIVE ||
+                                     other->job->type == JOB_RELOAD_OR_START)) {
+                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY);
                                         recursed = true;
                                 }
 
-                        SET_FOREACH(other, u->meta.dependencies[UNIT_BOUND_BY], i)
-                                if (other->meta.job &&
-                                    (other->meta.job->type == JOB_START ||
-                                     other->meta.job->type == JOB_VERIFY_ACTIVE ||
-                                     other->meta.job->type == JOB_RELOAD_OR_START)) {
-                                        job_finish_and_invalidate(other->meta.job, JOB_DEPENDENCY);
+                        SET_FOREACH(other, u->dependencies[UNIT_BOUND_BY], i)
+                                if (other->job &&
+                                    (other->job->type == JOB_START ||
+                                     other->job->type == JOB_VERIFY_ACTIVE ||
+                                     other->job->type == JOB_RELOAD_OR_START)) {
+                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY);
                                         recursed = true;
                                 }
 
-                        SET_FOREACH(other, u->meta.dependencies[UNIT_REQUIRED_BY_OVERRIDABLE], i)
-                                if (other->meta.job &&
-                                    !other->meta.job->override &&
-                                    (other->meta.job->type == JOB_START ||
-                                     other->meta.job->type == JOB_VERIFY_ACTIVE ||
-                                     other->meta.job->type == JOB_RELOAD_OR_START)) {
-                                        job_finish_and_invalidate(other->meta.job, JOB_DEPENDENCY);
+                        SET_FOREACH(other, u->dependencies[UNIT_REQUIRED_BY_OVERRIDABLE], i)
+                                if (other->job &&
+                                    !other->job->override &&
+                                    (other->job->type == JOB_START ||
+                                     other->job->type == JOB_VERIFY_ACTIVE ||
+                                     other->job->type == JOB_RELOAD_OR_START)) {
+                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY);
                                         recursed = true;
                                 }
 
                 } else if (t == JOB_STOP) {
 
-                        SET_FOREACH(other, u->meta.dependencies[UNIT_CONFLICTED_BY], i)
-                                if (other->meta.job &&
-                                    (other->meta.job->type == JOB_START ||
-                                     other->meta.job->type == JOB_VERIFY_ACTIVE ||
-                                     other->meta.job->type == JOB_RELOAD_OR_START)) {
-                                        job_finish_and_invalidate(other->meta.job, JOB_DEPENDENCY);
+                        SET_FOREACH(other, u->dependencies[UNIT_CONFLICTED_BY], i)
+                                if (other->job &&
+                                    (other->job->type == JOB_START ||
+                                     other->job->type == JOB_VERIFY_ACTIVE ||
+                                     other->job->type == JOB_RELOAD_OR_START)) {
+                                        job_finish_and_invalidate(other->job, JOB_DEPENDENCY);
                                         recursed = true;
                                 }
                 }
@@ -618,7 +618,7 @@ int job_finish_and_invalidate(Job *j, JobResult result) {
          * unit itself. */
         if (result == JOB_TIMEOUT || result == JOB_DEPENDENCY) {
                 log_notice("Job %s/%s failed with result '%s'.",
-                           u->meta.id,
+                           u->id,
                            job_type_to_string(t),
                            job_result_to_string(result));
 
@@ -627,14 +627,14 @@ int job_finish_and_invalidate(Job *j, JobResult result) {
 
 finish:
         /* Try to start the next jobs that can be started */
-        SET_FOREACH(other, u->meta.dependencies[UNIT_AFTER], i)
-                if (other->meta.job)
-                        job_add_to_run_queue(other->meta.job);
-        SET_FOREACH(other, u->meta.dependencies[UNIT_BEFORE], i)
-                if (other->meta.job)
-                        job_add_to_run_queue(other->meta.job);
+        SET_FOREACH(other, u->dependencies[UNIT_AFTER], i)
+                if (other->job)
+                        job_add_to_run_queue(other->job);
+        SET_FOREACH(other, u->dependencies[UNIT_BEFORE], i)
+                if (other->job)
+                        job_add_to_run_queue(other->job);
 
-        manager_check_finished(u->meta.manager);
+        manager_check_finished(u->manager);
 
         return recursed;
 }
@@ -645,7 +645,7 @@ int job_start_timer(Job *j) {
         int fd, r;
         assert(j);
 
-        if (j->unit->meta.job_timeout <= 0 ||
+        if (j->unit->job_timeout <= 0 ||
             j->timer_watch.type == WATCH_JOB_TIMER)
                 return 0;
 
@@ -657,7 +657,7 @@ int job_start_timer(Job *j) {
         }
 
         zero(its);
-        timespec_store(&its.it_value, j->unit->meta.job_timeout);
+        timespec_store(&its.it_value, j->unit->job_timeout);
 
         if (timerfd_settime(fd, 0, &its, NULL) < 0) {
                 r = -errno;
@@ -727,7 +727,7 @@ void job_timer_event(Job *j, uint64_t n_elapsed, Watch *w) {
         assert(j);
         assert(w == &j->timer_watch);
 
-        log_warning("Job %s/%s timed out.", j->unit->meta.id, job_type_to_string(j->type));
+        log_warning("Job %s/%s timed out.", j->unit->id, job_type_to_string(j->type));
         job_finish_and_invalidate(j, JOB_TIMEOUT);
 }
 
diff --git a/src/load-dropin.c b/src/load-dropin.c
index d114faa..d869ee0 100644
--- a/src/load-dropin.c
+++ b/src/load-dropin.c
@@ -61,7 +61,7 @@ static int iterate_dir(Unit *u, const char *path, UnitDependency dependency) {
                 free(f);
 
                 if (r < 0)
-                        log_error("Cannot add dependency %s to %s, ignoring: %s", de->d_name, u->meta.id, strerror(-r));
+                        log_error("Cannot add dependency %s to %s, ignoring: %s", de->d_name, u->id, strerror(-r));
         }
 
         r = 0;
@@ -84,8 +84,8 @@ static int process_dir(Unit *u, const char *unit_path, const char *name, const c
         if (!path)
                 return -ENOMEM;
 
-        if (u->meta.manager->unit_path_cache &&
-            !set_get(u->meta.manager->unit_path_cache, path))
+        if (u->manager->unit_path_cache &&
+            !set_get(u->manager->unit_path_cache, path))
                 r = 0;
         else
                 r = iterate_dir(u, path, dependency);
@@ -94,7 +94,7 @@ static int process_dir(Unit *u, const char *unit_path, const char *name, const c
         if (r < 0)
                 return r;
 
-        if (u->meta.instance) {
+        if (u->instance) {
                 char *template;
                 /* Also try the template dir */
 
@@ -108,8 +108,8 @@ static int process_dir(Unit *u, const char *unit_path, const char *name, const c
                 if (!path)
                         return -ENOMEM;
 
-                if (u->meta.manager->unit_path_cache &&
-                    !set_get(u->meta.manager->unit_path_cache, path))
+                if (u->manager->unit_path_cache &&
+                    !set_get(u->manager->unit_path_cache, path))
                         r = 0;
                 else
                         r = iterate_dir(u, path, dependency);
@@ -130,10 +130,10 @@ int unit_load_dropin(Unit *u) {
 
         /* Load dependencies from supplementary drop-in directories */
 
-        SET_FOREACH(t, u->meta.names, i) {
+        SET_FOREACH(t, u->names, i) {
                 char **p;
 
-                STRV_FOREACH(p, u->meta.manager->lookup_paths.unit_path) {
+                STRV_FOREACH(p, u->manager->lookup_paths.unit_path) {
                         int r;
 
                         r = process_dir(u, *p, t, ".wants", UNIT_WANTS);
diff --git a/src/load-fragment-gperf.gperf.m4 b/src/load-fragment-gperf.gperf.m4
index 6c764cb..e2b6522 100644
--- a/src/load-fragment-gperf.gperf.m4
+++ b/src/load-fragment-gperf.gperf.m4
@@ -89,7 +89,7 @@ $1.UtmpIdentifier,               config_parse_unit_string_printf,    0,
 $1.ControlGroupModify,           config_parse_bool,                  0,                             offsetof($1, exec_context.control_group_modify)'
 )m4_dnl
 Unit.Names,                      config_parse_unit_names,            0,                             0
-Unit.Description,                config_parse_unit_string_printf,    0,                             offsetof(Meta, description)
+Unit.Description,                config_parse_unit_string_printf,    0,                             offsetof(Unit, description)
 Unit.Requires,                   config_parse_unit_deps,             UNIT_REQUIRES,                 0
 Unit.RequiresOverridable,        config_parse_unit_deps,             UNIT_REQUIRES_OVERRIDABLE,     0
 Unit.Requisite,                  config_parse_unit_deps,             UNIT_REQUISITE,                0
@@ -102,15 +102,15 @@ Unit.After,                      config_parse_unit_deps,             UNIT_AFTER,
 Unit.OnFailure,                  config_parse_unit_deps,             UNIT_ON_FAILURE,               0
 Unit.PropagateReloadTo,          config_parse_unit_deps,             UNIT_PROPAGATE_RELOAD_TO,      0
 Unit.PropagateReloadFrom,        config_parse_unit_deps,             UNIT_PROPAGATE_RELOAD_FROM,    0
-Unit.StopWhenUnneeded,           config_parse_bool,                  0,                             offsetof(Meta, stop_when_unneeded)
-Unit.RefuseManualStart,          config_parse_bool,                  0,                             offsetof(Meta, refuse_manual_start)
-Unit.RefuseManualStop,           config_parse_bool,                  0,                             offsetof(Meta, refuse_manual_stop)
-Unit.AllowIsolate,               config_parse_bool,                  0,                             offsetof(Meta, allow_isolate)
-Unit.DefaultDependencies,        config_parse_bool,                  0,                             offsetof(Meta, default_dependencies)
-Unit.OnFailureIsolate,           config_parse_bool,                  0,                             offsetof(Meta, on_failure_isolate)
-Unit.IgnoreOnIsolate,            config_parse_bool,                  0,                             offsetof(Meta, ignore_on_isolate)
-Unit.IgnoreOnSnapshot,           config_parse_bool,                  0,                             offsetof(Meta, ignore_on_snapshot)
-Unit.JobTimeoutSec,              config_parse_usec,                  0,                             offsetof(Meta, job_timeout)
+Unit.StopWhenUnneeded,           config_parse_bool,                  0,                             offsetof(Unit, stop_when_unneeded)
+Unit.RefuseManualStart,          config_parse_bool,                  0,                             offsetof(Unit, refuse_manual_start)
+Unit.RefuseManualStop,           config_parse_bool,                  0,                             offsetof(Unit, refuse_manual_stop)
+Unit.AllowIsolate,               config_parse_bool,                  0,                             offsetof(Unit, allow_isolate)
+Unit.DefaultDependencies,        config_parse_bool,                  0,                             offsetof(Unit, default_dependencies)
+Unit.OnFailureIsolate,           config_parse_bool,                  0,                             offsetof(Unit, on_failure_isolate)
+Unit.IgnoreOnIsolate,            config_parse_bool,                  0,                             offsetof(Unit, ignore_on_isolate)
+Unit.IgnoreOnSnapshot,           config_parse_bool,                  0,                             offsetof(Unit, ignore_on_snapshot)
+Unit.JobTimeoutSec,              config_parse_usec,                  0,                             offsetof(Unit, job_timeout)
 Unit.ConditionPathExists,        config_parse_unit_condition_path,   CONDITION_PATH_EXISTS,         0
 Unit.ConditionPathExistsGlob,    config_parse_unit_condition_path,   CONDITION_PATH_EXISTS_GLOB,    0
 Unit.ConditionPathIsDirectory,   config_parse_unit_condition_path,   CONDITION_PATH_IS_DIRECTORY,   0
diff --git a/src/load-fragment.c b/src/load-fragment.c
index 1d4a8c1..88392d2 100644
--- a/src/load-fragment.c
+++ b/src/load-fragment.c
@@ -1583,7 +1583,7 @@ int config_parse_unit_condition_path(
         if (!c)
                 return -ENOMEM;
 
-        LIST_PREPEND(Condition, conditions, u->meta.conditions, c);
+        LIST_PREPEND(Condition, conditions, u->conditions, c);
         return 0;
 }
 
@@ -1616,7 +1616,7 @@ int config_parse_unit_condition_string(
         if (!(c = condition_new(cond, rvalue, trigger, negate)))
                 return -ENOMEM;
 
-        LIST_PREPEND(Condition, conditions, u->meta.conditions, c);
+        LIST_PREPEND(Condition, conditions, u->conditions, c);
         return 0;
 }
 
@@ -1657,7 +1657,7 @@ int config_parse_unit_condition_null(
         if (!(c = condition_new(CONDITION_NULL, NULL, trigger, negate)))
                 return -ENOMEM;
 
-        LIST_PREPEND(Condition, conditions, u->meta.conditions, c);
+        LIST_PREPEND(Condition, conditions, u->conditions, c);
         return 0;
 }
 
@@ -2123,7 +2123,7 @@ static int merge_by_names(Unit **u, Set *names, const char *id) {
                          * ours? Then let's try it the other way
                          * round */
 
-                        other = manager_get_unit((*u)->meta.manager, k);
+                        other = manager_get_unit((*u)->manager, k);
                         free(k);
 
                         if (other)
@@ -2177,7 +2177,7 @@ static int load_from_path(Unit *u, const char *path) {
         } else  {
                 char **p;
 
-                STRV_FOREACH(p, u->meta.manager->lookup_paths.unit_path) {
+                STRV_FOREACH(p, u->manager->lookup_paths.unit_path) {
 
                         /* Instead of opening the path right away, we manually
                          * follow all symlinks and add their name to our unit
@@ -2187,8 +2187,8 @@ static int load_from_path(Unit *u, const char *path) {
                                 goto finish;
                         }
 
-                        if (u->meta.manager->unit_path_cache &&
-                            !set_get(u->meta.manager->unit_path_cache, filename))
+                        if (u->manager->unit_path_cache &&
+                            !set_get(u->manager->unit_path_cache, filename))
                                 r = -ENOENT;
                         else
                                 r = open_follow(&filename, &f, symlink_names, &id);
@@ -2224,7 +2224,7 @@ static int load_from_path(Unit *u, const char *path) {
                 goto finish;
 
         if (merged != u) {
-                u->meta.load_state = UNIT_MERGED;
+                u->load_state = UNIT_MERGED;
                 r = 0;
                 goto finish;
         }
@@ -2236,21 +2236,21 @@ static int load_from_path(Unit *u, const char *path) {
         }
 
         if (null_or_empty(&st))
-                u->meta.load_state = UNIT_MASKED;
+                u->load_state = UNIT_MASKED;
         else {
                 /* Now, parse the file contents */
                 r = config_parse(filename, f, UNIT_VTABLE(u)->sections, config_item_perf_lookup, (void*) load_fragment_gperf_lookup, false, u);
                 if (r < 0)
                         goto finish;
 
-                u->meta.load_state = UNIT_LOADED;
+                u->load_state = UNIT_LOADED;
         }
 
-        free(u->meta.fragment_path);
-        u->meta.fragment_path = filename;
+        free(u->fragment_path);
+        u->fragment_path = filename;
         filename = NULL;
 
-        u->meta.fragment_mtime = timespec_load(&st.st_mtim);
+        u->fragment_mtime = timespec_load(&st.st_mtim);
 
         r = 0;
 
@@ -2270,49 +2270,49 @@ int unit_load_fragment(Unit *u) {
         const char *t;
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
-        assert(u->meta.id);
+        assert(u->load_state == UNIT_STUB);
+        assert(u->id);
 
         /* First, try to find the unit under its id. We always look
          * for unit files in the default directories, to make it easy
          * to override things by placing things in /etc/systemd/system */
-        if ((r = load_from_path(u, u->meta.id)) < 0)
+        if ((r = load_from_path(u, u->id)) < 0)
                 return r;
 
         /* Try to find an alias we can load this with */
-        if (u->meta.load_state == UNIT_STUB)
-                SET_FOREACH(t, u->meta.names, i) {
+        if (u->load_state == UNIT_STUB)
+                SET_FOREACH(t, u->names, i) {
 
-                        if (t == u->meta.id)
+                        if (t == u->id)
                                 continue;
 
                         if ((r = load_from_path(u, t)) < 0)
                                 return r;
 
-                        if (u->meta.load_state != UNIT_STUB)
+                        if (u->load_state != UNIT_STUB)
                                 break;
                 }
 
         /* And now, try looking for it under the suggested (originally linked) path */
-        if (u->meta.load_state == UNIT_STUB && u->meta.fragment_path) {
+        if (u->load_state == UNIT_STUB && u->fragment_path) {
 
-                if ((r = load_from_path(u, u->meta.fragment_path)) < 0)
+                if ((r = load_from_path(u, u->fragment_path)) < 0)
                         return r;
 
-                if (u->meta.load_state == UNIT_STUB) {
+                if (u->load_state == UNIT_STUB) {
                         /* Hmm, this didn't work? Then let's get rid
                          * of the fragment path stored for us, so that
                          * we don't point to an invalid location. */
-                        free(u->meta.fragment_path);
-                        u->meta.fragment_path = NULL;
+                        free(u->fragment_path);
+                        u->fragment_path = NULL;
                 }
         }
 
         /* Look for a template */
-        if (u->meta.load_state == UNIT_STUB && u->meta.instance) {
+        if (u->load_state == UNIT_STUB && u->instance) {
                 char *k;
 
-                if (!(k = unit_name_template(u->meta.id)))
+                if (!(k = unit_name_template(u->id)))
                         return -ENOMEM;
 
                 r = load_from_path(u, k);
@@ -2321,10 +2321,10 @@ int unit_load_fragment(Unit *u) {
                 if (r < 0)
                         return r;
 
-                if (u->meta.load_state == UNIT_STUB)
-                        SET_FOREACH(t, u->meta.names, i) {
+                if (u->load_state == UNIT_STUB)
+                        SET_FOREACH(t, u->names, i) {
 
-                                if (t == u->meta.id)
+                                if (t == u->id)
                                         continue;
 
                                 if (!(k = unit_name_template(t)))
@@ -2336,7 +2336,7 @@ int unit_load_fragment(Unit *u) {
                                 if (r < 0)
                                         return r;
 
-                                if (u->meta.load_state != UNIT_STUB)
+                                if (u->load_state != UNIT_STUB)
                                         break;
                         }
         }
diff --git a/src/main.c b/src/main.c
index e691720..fec6594 100644
--- a/src/main.c
+++ b/src/main.c
@@ -1413,28 +1413,28 @@ int main(int argc, char *argv[]) {
                 if ((r = manager_load_unit(m, arg_default_unit, NULL, &error, &target)) < 0) {
                         log_error("Failed to load default target: %s", bus_error(&error, r));
                         dbus_error_free(&error);
-                } else if (target->meta.load_state == UNIT_ERROR)
-                        log_error("Failed to load default target: %s", strerror(-target->meta.load_error));
-                else if (target->meta.load_state == UNIT_MASKED)
+                } else if (target->load_state == UNIT_ERROR)
+                        log_error("Failed to load default target: %s", strerror(-target->load_error));
+                else if (target->load_state == UNIT_MASKED)
                         log_error("Default target masked.");
 
-                if (!target || target->meta.load_state != UNIT_LOADED) {
+                if (!target || target->load_state != UNIT_LOADED) {
                         log_info("Trying to load rescue target...");
 
                         if ((r = manager_load_unit(m, SPECIAL_RESCUE_TARGET, NULL, &error, &target)) < 0) {
                                 log_error("Failed to load rescue target: %s", bus_error(&error, r));
                                 dbus_error_free(&error);
                                 goto finish;
-                        } else if (target->meta.load_state == UNIT_ERROR) {
-                                log_error("Failed to load rescue target: %s", strerror(-target->meta.load_error));
+                        } else if (target->load_state == UNIT_ERROR) {
+                                log_error("Failed to load rescue target: %s", strerror(-target->load_error));
                                 goto finish;
-                        } else if (target->meta.load_state == UNIT_MASKED) {
+                        } else if (target->load_state == UNIT_MASKED) {
                                 log_error("Rescue target masked.");
                                 goto finish;
                         }
                 }
 
-                assert(target->meta.load_state == UNIT_LOADED);
+                assert(target->load_state == UNIT_LOADED);
 
                 if (arg_action == ACTION_TEST) {
                         printf("-> By units:\n");
diff --git a/src/manager.c b/src/manager.c
index e1c372b..78fafdf 100644
--- a/src/manager.c
+++ b/src/manager.c
@@ -304,7 +304,7 @@ fail:
 }
 
 static unsigned manager_dispatch_cleanup_queue(Manager *m) {
-        Meta *meta;
+        Unit *meta;
         unsigned n = 0;
 
         assert(m);
@@ -334,28 +334,28 @@ static void unit_gc_sweep(Unit *u, unsigned gc_marker) {
 
         assert(u);
 
-        if (u->meta.gc_marker == gc_marker + GC_OFFSET_GOOD ||
-            u->meta.gc_marker == gc_marker + GC_OFFSET_BAD ||
-            u->meta.gc_marker == gc_marker + GC_OFFSET_IN_PATH)
+        if (u->gc_marker == gc_marker + GC_OFFSET_GOOD ||
+            u->gc_marker == gc_marker + GC_OFFSET_BAD ||
+            u->gc_marker == gc_marker + GC_OFFSET_IN_PATH)
                 return;
 
-        if (u->meta.in_cleanup_queue)
+        if (u->in_cleanup_queue)
                 goto bad;
 
         if (unit_check_gc(u))
                 goto good;
 
-        u->meta.gc_marker = gc_marker + GC_OFFSET_IN_PATH;
+        u->gc_marker = gc_marker + GC_OFFSET_IN_PATH;
 
         is_bad = true;
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_REFERENCED_BY], i) {
+        SET_FOREACH(other, u->dependencies[UNIT_REFERENCED_BY], i) {
                 unit_gc_sweep(other, gc_marker);
 
-                if (other->meta.gc_marker == gc_marker + GC_OFFSET_GOOD)
+                if (other->gc_marker == gc_marker + GC_OFFSET_GOOD)
                         goto good;
 
-                if (other->meta.gc_marker != gc_marker + GC_OFFSET_BAD)
+                if (other->gc_marker != gc_marker + GC_OFFSET_BAD)
                         is_bad = false;
         }
 
@@ -364,23 +364,23 @@ static void unit_gc_sweep(Unit *u, unsigned gc_marker) {
 
         /* We were unable to find anything out about this entry, so
          * let's investigate it later */
-        u->meta.gc_marker = gc_marker + GC_OFFSET_UNSURE;
+        u->gc_marker = gc_marker + GC_OFFSET_UNSURE;
         unit_add_to_gc_queue(u);
         return;
 
 bad:
         /* We definitely know that this one is not useful anymore, so
          * let's mark it for deletion */
-        u->meta.gc_marker = gc_marker + GC_OFFSET_BAD;
+        u->gc_marker = gc_marker + GC_OFFSET_BAD;
         unit_add_to_cleanup_queue(u);
         return;
 
 good:
-        u->meta.gc_marker = gc_marker + GC_OFFSET_GOOD;
+        u->gc_marker = gc_marker + GC_OFFSET_GOOD;
 }
 
 static unsigned manager_dispatch_gc_queue(Manager *m) {
-        Meta *meta;
+        Unit *meta;
         unsigned n = 0;
         unsigned gc_marker;
 
@@ -404,7 +404,7 @@ static unsigned manager_dispatch_gc_queue(Manager *m) {
 
                 unit_gc_sweep((Unit*) meta, gc_marker);
 
-                LIST_REMOVE(Meta, gc_queue, m->gc_queue, meta);
+                LIST_REMOVE(Unit, gc_queue, m->gc_queue, meta);
                 meta->in_gc_queue = false;
 
                 n++;
@@ -528,7 +528,7 @@ int manager_coldplug(Manager *m) {
         HASHMAP_FOREACH_KEY(u, k, m->units, i) {
 
                 /* ignore aliases */
-                if (u->meta.id != k)
+                if (u->id != k)
                         continue;
 
                 if ((q = unit_coldplug(u)) < 0)
@@ -821,8 +821,8 @@ static int delete_one_unmergeable_job(Manager *m, Job *j) {
                                  * another unit in which case we
                                  * rather remove the start. */
 
-                                log_debug("Looking at job %s/%s conflicted_by=%s", j->unit->meta.id, job_type_to_string(j->type), yes_no(j->type == JOB_STOP && job_is_conflicted_by(j)));
-                                log_debug("Looking at job %s/%s conflicted_by=%s", k->unit->meta.id, job_type_to_string(k->type), yes_no(k->type == JOB_STOP && job_is_conflicted_by(k)));
+                                log_debug("Looking at job %s/%s conflicted_by=%s", j->unit->id, job_type_to_string(j->type), yes_no(j->type == JOB_STOP && job_is_conflicted_by(j)));
+                                log_debug("Looking at job %s/%s conflicted_by=%s", k->unit->id, job_type_to_string(k->type), yes_no(k->type == JOB_STOP && job_is_conflicted_by(k)));
 
                                 if (j->type == JOB_STOP) {
 
@@ -848,7 +848,7 @@ static int delete_one_unmergeable_job(Manager *m, Job *j) {
                                 return -ENOEXEC;
 
                         /* Ok, we can drop one, so let's do so. */
-                        log_debug("Fixing conflicting jobs by deleting job %s/%s", d->unit->meta.id, job_type_to_string(d->type));
+                        log_debug("Fixing conflicting jobs by deleting job %s/%s", d->unit->id, job_type_to_string(d->type));
                         transaction_delete_job(m, d, true);
                         return 0;
                 }
@@ -886,7 +886,7 @@ static int transaction_merge_jobs(Manager *m, DBusError *e) {
 
                         /* We couldn't merge anything. Failure */
                         dbus_set_error(e, BUS_ERROR_TRANSACTION_JOBS_CONFLICTING, "Transaction contains conflicting jobs '%s' and '%s' for %s. Probably contradicting requirement dependencies configured.",
-                                       job_type_to_string(t), job_type_to_string(k->type), k->unit->meta.id);
+                                       job_type_to_string(t), job_type_to_string(k->type), k->unit->id);
                         return r;
                 }
         }
@@ -901,8 +901,8 @@ static int transaction_merge_jobs(Manager *m, DBusError *e) {
                         assert_se(job_type_merge(&t, k->type) == 0);
 
                 /* If an active job is mergeable, merge it too */
-                if (j->unit->meta.job)
-                        job_type_merge(&t, j->unit->meta.job->type); /* Might fail. Which is OK */
+                if (j->unit->job)
+                        job_type_merge(&t, j->unit->job->type); /* Might fail. Which is OK */
 
                 while ((k = j->transaction_next)) {
                         if (j->installed) {
@@ -912,8 +912,8 @@ static int transaction_merge_jobs(Manager *m, DBusError *e) {
                                 transaction_merge_and_delete_job(m, j, k, t);
                 }
 
-                if (j->unit->meta.job && !j->installed)
-                        transaction_merge_and_delete_job(m, j, j->unit->meta.job, t);
+                if (j->unit->job && !j->installed)
+                        transaction_merge_and_delete_job(m, j, j->unit->job, t);
 
                 assert(!j->transaction_next);
                 assert(!j->transaction_prev);
@@ -944,7 +944,7 @@ static void transaction_drop_redundant(Manager *m) {
 
                                 if (!job_is_anchor(k) &&
                                     (k->installed || job_type_is_redundant(k->type, unit_active_state(k->unit))) &&
-                                    (!k->unit->meta.job || !job_type_is_conflicting(k->type, k->unit->meta.job->type)))
+                                    (!k->unit->job || !job_type_is_conflicting(k->type, k->unit->job->type)))
                                         continue;
 
                                 changes_something = true;
@@ -954,7 +954,7 @@ static void transaction_drop_redundant(Manager *m) {
                         if (changes_something)
                                 continue;
 
-                        /* log_debug("Found redundant job %s/%s, dropping.", j->unit->meta.id, job_type_to_string(j->type)); */
+                        /* log_debug("Found redundant job %s/%s, dropping.", j->unit->id, job_type_to_string(j->type)); */
                         transaction_delete_job(m, j, false);
                         again = true;
                         break;
@@ -1005,12 +1005,12 @@ static int transaction_verify_order_one(Manager *m, Job *j, Job *from, unsigned
                  * job to remove. We use the marker to find our way
                  * back, since smart how we are we stored our way back
                  * in there. */
-                log_warning("Found ordering cycle on %s/%s", j->unit->meta.id, job_type_to_string(j->type));
+                log_warning("Found ordering cycle on %s/%s", j->unit->id, job_type_to_string(j->type));
 
                 delete = NULL;
                 for (k = from; k; k = ((k->generation == generation && k->marker != k) ? k->marker : NULL)) {
 
-                        log_info("Walked on cycle path to %s/%s", k->unit->meta.id, job_type_to_string(k->type));
+                        log_info("Walked on cycle path to %s/%s", k->unit->id, job_type_to_string(k->type));
 
                         if (!delete &&
                             !k->installed &&
@@ -1028,7 +1028,7 @@ static int transaction_verify_order_one(Manager *m, Job *j, Job *from, unsigned
 
 
                 if (delete) {
-                        log_warning("Breaking ordering cycle by deleting job %s/%s", delete->unit->meta.id, job_type_to_string(delete->type));
+                        log_warning("Breaking ordering cycle by deleting job %s/%s", delete->unit->id, job_type_to_string(delete->type));
                         transaction_delete_unit(m, delete->unit);
                         return -EAGAIN;
                 }
@@ -1048,7 +1048,7 @@ static int transaction_verify_order_one(Manager *m, Job *j, Job *from, unsigned
 
         /* We assume that the the dependencies are bidirectional, and
          * hence can ignore UNIT_AFTER */
-        SET_FOREACH(u, j->unit->meta.dependencies[UNIT_BEFORE], i) {
+        SET_FOREACH(u, j->unit->dependencies[UNIT_BEFORE], i) {
                 Job *o;
 
                 /* Is there a job for this unit? */
@@ -1057,7 +1057,7 @@ static int transaction_verify_order_one(Manager *m, Job *j, Job *from, unsigned
                         /* Ok, there is no job for this in the
                          * transaction, but maybe there is already one
                          * running? */
-                        if (!(o = u->meta.job))
+                        if (!(o = u->job))
                                 continue;
 
                 if ((r = transaction_verify_order_one(m, o, j, generation, e)) < 0)
@@ -1108,13 +1108,13 @@ static void transaction_collect_garbage(Manager *m) {
                 HASHMAP_FOREACH(j, m->transaction_jobs, i) {
                         if (j->object_list) {
                                 /* log_debug("Keeping job %s/%s because of %s/%s", */
-                                /*           j->unit->meta.id, job_type_to_string(j->type), */
-                                /*           j->object_list->subject ? j->object_list->subject->unit->meta.id : "root", */
+                                /*           j->unit->id, job_type_to_string(j->type), */
+                                /*           j->object_list->subject ? j->object_list->subject->unit->id : "root", */
                                 /*           j->object_list->subject ? job_type_to_string(j->object_list->subject->type) : "root"); */
                                 continue;
                         }
 
-                        /* log_debug("Garbage collecting job %s/%s", j->unit->meta.id, job_type_to_string(j->type)); */
+                        /* log_debug("Garbage collecting job %s/%s", j->unit->id, job_type_to_string(j->type)); */
                         transaction_delete_job(m, j, true);
                         again = true;
                         break;
@@ -1138,9 +1138,9 @@ static int transaction_is_destructive(Manager *m, DBusError *e) {
                 assert(!j->transaction_prev);
                 assert(!j->transaction_next);
 
-                if (j->unit->meta.job &&
-                    j->unit->meta.job != j &&
-                    !job_type_is_superset(j->type, j->unit->meta.job->type)) {
+                if (j->unit->job &&
+                    j->unit->job != j &&
+                    !job_type_is_superset(j->type, j->unit->job->type)) {
 
                         dbus_set_error(e, BUS_ERROR_TRANSACTION_IS_DESTRUCTIVE, "Transaction is destructive.");
                         return -EEXIST;
@@ -1179,20 +1179,20 @@ static void transaction_minimize_impact(Manager *m) {
                                         j->type == JOB_STOP && UNIT_IS_ACTIVE_OR_ACTIVATING(unit_active_state(j->unit));
 
                                 changes_existing_job =
-                                        j->unit->meta.job &&
-                                        job_type_is_conflicting(j->type, j->unit->meta.job->type);
+                                        j->unit->job &&
+                                        job_type_is_conflicting(j->type, j->unit->job->type);
 
                                 if (!stops_running_service && !changes_existing_job)
                                         continue;
 
                                 if (stops_running_service)
-                                        log_debug("%s/%s would stop a running service.", j->unit->meta.id, job_type_to_string(j->type));
+                                        log_debug("%s/%s would stop a running service.", j->unit->id, job_type_to_string(j->type));
 
                                 if (changes_existing_job)
-                                        log_debug("%s/%s would change existing job.", j->unit->meta.id, job_type_to_string(j->type));
+                                        log_debug("%s/%s would change existing job.", j->unit->id, job_type_to_string(j->type));
 
                                 /* Ok, let's get rid of this */
-                                log_debug("Deleting %s/%s to minimize impact.", j->unit->meta.id, job_type_to_string(j->type));
+                                log_debug("Deleting %s/%s to minimize impact.", j->unit->id, job_type_to_string(j->type));
 
                                 transaction_delete_job(m, j, true);
                                 again = true;
@@ -1246,14 +1246,14 @@ static int transaction_apply(Manager *m, JobMode mode) {
 
         while ((j = hashmap_steal_first(m->transaction_jobs))) {
                 if (j->installed) {
-                        /* log_debug("Skipping already installed job %s/%s as %u", j->unit->meta.id, job_type_to_string(j->type), (unsigned) j->id); */
+                        /* log_debug("Skipping already installed job %s/%s as %u", j->unit->id, job_type_to_string(j->type), (unsigned) j->id); */
                         continue;
                 }
 
-                if (j->unit->meta.job)
-                        job_free(j->unit->meta.job);
+                if (j->unit->job)
+                        job_free(j->unit->job);
 
-                j->unit->meta.job = j;
+                j->unit->job = j;
                 j->installed = true;
                 m->n_installed_jobs ++;
 
@@ -1267,7 +1267,7 @@ static int transaction_apply(Manager *m, JobMode mode) {
                 job_add_to_dbus_queue(j);
                 job_start_timer(j);
 
-                log_debug("Installed new job %s/%s as %u", j->unit->meta.id, job_type_to_string(j->type), (unsigned) j->id);
+                log_debug("Installed new job %s/%s as %u", j->unit->id, job_type_to_string(j->type), (unsigned) j->id);
         }
 
         /* As last step, kill all remaining job dependencies. */
@@ -1397,8 +1397,8 @@ static Job* transaction_add_one_job(Manager *m, JobType type, Unit *unit, bool o
                 }
         }
 
-        if (unit->meta.job && unit->meta.job->type == type)
-                j = unit->meta.job;
+        if (unit->job && unit->job->type == type)
+                j = unit->job;
         else if (!(j = job_new(m, type, unit)))
                 return NULL;
 
@@ -1417,7 +1417,7 @@ static Job* transaction_add_one_job(Manager *m, JobType type, Unit *unit, bool o
         if (is_new)
                 *is_new = true;
 
-        /* log_debug("Added job %s/%s to transaction.", unit->meta.id, job_type_to_string(type)); */
+        /* log_debug("Added job %s/%s to transaction.", unit->id, job_type_to_string(type)); */
 
         return j;
 }
@@ -1448,8 +1448,8 @@ void manager_transaction_unlink_job(Manager *m, Job *j, bool delete_dependencies
 
                 if (other && delete_dependencies) {
                         log_debug("Deleting job %s/%s as dependency of job %s/%s",
-                                  other->unit->meta.id, job_type_to_string(other->type),
-                                  j->unit->meta.id, job_type_to_string(j->type));
+                                  other->unit->id, job_type_to_string(other->type),
+                                  j->unit->id, job_type_to_string(j->type));
                         transaction_delete_job(m, other, delete_dependencies);
                 }
         }
@@ -1478,34 +1478,34 @@ static int transaction_add_job_and_dependencies(
         assert(unit);
 
         /* log_debug("Pulling in %s/%s from %s/%s", */
-        /*           unit->meta.id, job_type_to_string(type), */
-        /*           by ? by->unit->meta.id : "NA", */
+        /*           unit->id, job_type_to_string(type), */
+        /*           by ? by->unit->id : "NA", */
         /*           by ? job_type_to_string(by->type) : "NA"); */
 
-        if (unit->meta.load_state != UNIT_LOADED &&
-            unit->meta.load_state != UNIT_ERROR &&
-            unit->meta.load_state != UNIT_MASKED) {
-                dbus_set_error(e, BUS_ERROR_LOAD_FAILED, "Unit %s is not loaded properly.", unit->meta.id);
+        if (unit->load_state != UNIT_LOADED &&
+            unit->load_state != UNIT_ERROR &&
+            unit->load_state != UNIT_MASKED) {
+                dbus_set_error(e, BUS_ERROR_LOAD_FAILED, "Unit %s is not loaded properly.", unit->id);
                 return -EINVAL;
         }
 
-        if (type != JOB_STOP && unit->meta.load_state == UNIT_ERROR) {
+        if (type != JOB_STOP && unit->load_state == UNIT_ERROR) {
                 dbus_set_error(e, BUS_ERROR_LOAD_FAILED,
                                "Unit %s failed to load: %s. "
                                "See system logs and 'systemctl status %s' for details.",
-                               unit->meta.id,
-                               strerror(-unit->meta.load_error),
-                               unit->meta.id);
+                               unit->id,
+                               strerror(-unit->load_error),
+                               unit->id);
                 return -EINVAL;
         }
 
-        if (type != JOB_STOP && unit->meta.load_state == UNIT_MASKED) {
-                dbus_set_error(e, BUS_ERROR_MASKED, "Unit %s is masked.", unit->meta.id);
+        if (type != JOB_STOP && unit->load_state == UNIT_MASKED) {
+                dbus_set_error(e, BUS_ERROR_MASKED, "Unit %s is masked.", unit->id);
                 return -EINVAL;
         }
 
         if (!unit_job_is_applicable(unit, type)) {
-                dbus_set_error(e, BUS_ERROR_JOB_TYPE_NOT_APPLICABLE, "Job type %s is not applicable for unit %s.", job_type_to_string(type), unit->meta.id);
+                dbus_set_error(e, BUS_ERROR_JOB_TYPE_NOT_APPLICABLE, "Job type %s is not applicable for unit %s.", job_type_to_string(type), unit->id);
                 return -EBADR;
         }
 
@@ -1527,7 +1527,7 @@ static int transaction_add_job_and_dependencies(
                 if (unit_following_set(ret->unit, &following) > 0) {
                         SET_FOREACH(dep, following, i)
                                 if ((r = transaction_add_job_and_dependencies(m, type, dep, ret, false, override, false, false, ignore_order, e, NULL)) < 0) {
-                                        log_warning("Cannot add dependency job for unit %s, ignoring: %s", dep->meta.id, bus_error(e, r));
+                                        log_warning("Cannot add dependency job for unit %s, ignoring: %s", dep->id, bus_error(e, r));
 
                                         if (e)
                                                 dbus_error_free(e);
@@ -1538,7 +1538,7 @@ static int transaction_add_job_and_dependencies(
 
                 /* Finally, recursively add in all dependencies. */
                 if (type == JOB_START || type == JOB_RELOAD_OR_START) {
-                        SET_FOREACH(dep, ret->unit->meta.dependencies[UNIT_REQUIRES], i)
+                        SET_FOREACH(dep, ret->unit->dependencies[UNIT_REQUIRES], i)
                                 if ((r = transaction_add_job_and_dependencies(m, JOB_START, dep, ret, true, override, false, false, ignore_order, e, NULL)) < 0) {
                                         if (r != -EBADR)
                                                 goto fail;
@@ -1547,7 +1547,7 @@ static int transaction_add_job_and_dependencies(
                                                 dbus_error_free(e);
                                 }
 
-                        SET_FOREACH(dep, ret->unit->meta.dependencies[UNIT_BIND_TO], i)
+                        SET_FOREACH(dep, ret->unit->dependencies[UNIT_BIND_TO], i)
                                 if ((r = transaction_add_job_and_dependencies(m, JOB_START, dep, ret, true, override, false, false, ignore_order, e, NULL)) < 0) {
 
                                         if (r != -EBADR)
@@ -1557,23 +1557,23 @@ static int transaction_add_job_and_dependencies(
                                                 dbus_error_free(e);
                                 }
 
-                        SET_FOREACH(dep, ret->unit->meta.dependencies[UNIT_REQUIRES_OVERRIDABLE], i)
+                        SET_FOREACH(dep, ret->unit->dependencies[UNIT_REQUIRES_OVERRIDABLE], i)
                                 if ((r = transaction_add_job_and_dependencies(m, JOB_START, dep, ret, !override, override, false, false, ignore_order, e, NULL)) < 0) {
-                                        log_warning("Cannot add dependency job for unit %s, ignoring: %s", dep->meta.id, bus_error(e, r));
+                                        log_warning("Cannot add dependency job for unit %s, ignoring: %s", dep->id, bus_error(e, r));
 
                                         if (e)
                                                 dbus_error_free(e);
                                 }
 
-                        SET_FOREACH(dep, ret->unit->meta.dependencies[UNIT_WANTS], i)
+                        SET_FOREACH(dep, ret->unit->dependencies[UNIT_WANTS], i)
                                 if ((r = transaction_add_job_and_dependencies(m, JOB_START, dep, ret, false, false, false, false, ignore_order, e, NULL)) < 0) {
-                                        log_warning("Cannot add dependency job for unit %s, ignoring: %s", dep->meta.id, bus_error(e, r));
+                                        log_warning("Cannot add dependency job for unit %s, ignoring: %s", dep->id, bus_error(e, r));
 
                                         if (e)
                                                 dbus_error_free(e);
                                 }
 
-                        SET_FOREACH(dep, ret->unit->meta.dependencies[UNIT_REQUISITE], i)
+                        SET_FOREACH(dep, ret->unit->dependencies[UNIT_REQUISITE], i)
                                 if ((r = transaction_add_job_and_dependencies(m, JOB_VERIFY_ACTIVE, dep, ret, true, override, false, false, ignore_order, e, NULL)) < 0) {
 
                                         if (r != -EBADR)
@@ -1583,15 +1583,15 @@ static int transaction_add_job_and_dependencies(
                                                 dbus_error_free(e);
                                 }
 
-                        SET_FOREACH(dep, ret->unit->meta.dependencies[UNIT_REQUISITE_OVERRIDABLE], i)
+                        SET_FOREACH(dep, ret->unit->dependencies[UNIT_REQUISITE_OVERRIDABLE], i)
                                 if ((r = transaction_add_job_and_dependencies(m, JOB_VERIFY_ACTIVE, dep, ret, !override, override, false, false, ignore_order, e, NULL)) < 0) {
-                                        log_warning("Cannot add dependency job for unit %s, ignoring: %s", dep->meta.id, bus_error(e, r));
+                                        log_warning("Cannot add dependency job for unit %s, ignoring: %s", dep->id, bus_error(e, r));
 
                                         if (e)
                                                 dbus_error_free(e);
                                 }
 
-                        SET_FOREACH(dep, ret->unit->meta.dependencies[UNIT_CONFLICTS], i)
+                        SET_FOREACH(dep, ret->unit->dependencies[UNIT_CONFLICTS], i)
                                 if ((r = transaction_add_job_and_dependencies(m, JOB_STOP, dep, ret, true, override, true, false, ignore_order, e, NULL)) < 0) {
 
                                         if (r != -EBADR)
@@ -1601,9 +1601,9 @@ static int transaction_add_job_and_dependencies(
                                                 dbus_error_free(e);
                                 }
 
-                        SET_FOREACH(dep, ret->unit->meta.dependencies[UNIT_CONFLICTED_BY], i)
+                        SET_FOREACH(dep, ret->unit->dependencies[UNIT_CONFLICTED_BY], i)
                                 if ((r = transaction_add_job_and_dependencies(m, JOB_STOP, dep, ret, false, override, false, false, ignore_order, e, NULL)) < 0) {
-                                        log_warning("Cannot add dependency job for unit %s, ignoring: %s", dep->meta.id, bus_error(e, r));
+                                        log_warning("Cannot add dependency job for unit %s, ignoring: %s", dep->id, bus_error(e, r));
 
                                         if (e)
                                                 dbus_error_free(e);
@@ -1613,7 +1613,7 @@ static int transaction_add_job_and_dependencies(
 
                 if (type == JOB_STOP || type == JOB_RESTART || type == JOB_TRY_RESTART) {
 
-                        SET_FOREACH(dep, ret->unit->meta.dependencies[UNIT_REQUIRED_BY], i)
+                        SET_FOREACH(dep, ret->unit->dependencies[UNIT_REQUIRED_BY], i)
                                 if ((r = transaction_add_job_and_dependencies(m, type, dep, ret, true, override, false, false, ignore_order, e, NULL)) < 0) {
 
                                         if (r != -EBADR)
@@ -1623,7 +1623,7 @@ static int transaction_add_job_and_dependencies(
                                                 dbus_error_free(e);
                                 }
 
-                        SET_FOREACH(dep, ret->unit->meta.dependencies[UNIT_BOUND_BY], i)
+                        SET_FOREACH(dep, ret->unit->dependencies[UNIT_BOUND_BY], i)
                                 if ((r = transaction_add_job_and_dependencies(m, type, dep, ret, true, override, false, false, ignore_order, e, NULL)) < 0) {
 
                                         if (r != -EBADR)
@@ -1636,11 +1636,11 @@ static int transaction_add_job_and_dependencies(
 
                 if (type == JOB_RELOAD || type == JOB_RELOAD_OR_START) {
 
-                        SET_FOREACH(dep, ret->unit->meta.dependencies[UNIT_PROPAGATE_RELOAD_TO], i) {
+                        SET_FOREACH(dep, ret->unit->dependencies[UNIT_PROPAGATE_RELOAD_TO], i) {
                                 r = transaction_add_job_and_dependencies(m, JOB_RELOAD, dep, ret, false, override, false, false, ignore_order, e, NULL);
 
                                 if (r < 0) {
-                                        log_warning("Cannot add dependency reload job for unit %s, ignoring: %s", dep->meta.id, bus_error(e, r));
+                                        log_warning("Cannot add dependency reload job for unit %s, ignoring: %s", dep->id, bus_error(e, r));
 
                                         if (e)
                                                 dbus_error_free(e);
@@ -1671,14 +1671,14 @@ static int transaction_add_isolate_jobs(Manager *m) {
         HASHMAP_FOREACH_KEY(u, k, m->units, i) {
 
                 /* ignore aliases */
-                if (u->meta.id != k)
+                if (u->id != k)
                         continue;
 
-                if (u->meta.ignore_on_isolate)
+                if (u->ignore_on_isolate)
                         continue;
 
                 /* No need to stop inactive jobs */
-                if (UNIT_IS_INACTIVE_OR_FAILED(unit_active_state(u)) && !u->meta.job)
+                if (UNIT_IS_INACTIVE_OR_FAILED(unit_active_state(u)) && !u->job)
                         continue;
 
                 /* Is there already something listed for this? */
@@ -1686,7 +1686,7 @@ static int transaction_add_isolate_jobs(Manager *m) {
                         continue;
 
                 if ((r = transaction_add_job_and_dependencies(m, JOB_STOP, u, NULL, true, false, false, false, false, NULL, NULL)) < 0)
-                        log_warning("Cannot add isolate job for unit %s, ignoring: %s", u->meta.id, strerror(-r));
+                        log_warning("Cannot add isolate job for unit %s, ignoring: %s", u->id, strerror(-r));
         }
 
         return 0;
@@ -1706,12 +1706,12 @@ int manager_add_job(Manager *m, JobType type, Unit *unit, JobMode mode, bool ove
                 return -EINVAL;
         }
 
-        if (mode == JOB_ISOLATE && !unit->meta.allow_isolate) {
+        if (mode == JOB_ISOLATE && !unit->allow_isolate) {
                 dbus_set_error(e, BUS_ERROR_NO_ISOLATION, "Operation refused, unit may not be isolated.");
                 return -EPERM;
         }
 
-        log_debug("Trying to enqueue job %s/%s/%s", unit->meta.id, job_type_to_string(type), job_mode_to_string(mode));
+        log_debug("Trying to enqueue job %s/%s/%s", unit->id, job_type_to_string(type), job_mode_to_string(mode));
 
         if ((r = transaction_add_job_and_dependencies(m, type, unit, NULL, true, override, false,
                                                       mode == JOB_IGNORE_DEPENDENCIES || mode == JOB_IGNORE_REQUIREMENTS,
@@ -1729,7 +1729,7 @@ int manager_add_job(Manager *m, JobType type, Unit *unit, JobMode mode, bool ove
         if ((r = transaction_activate(m, mode, e)) < 0)
                 return r;
 
-        log_debug("Enqueued job %s/%s as %u", unit->meta.id, job_type_to_string(type), (unsigned) ret->id);
+        log_debug("Enqueued job %s/%s as %u", unit->id, job_type_to_string(type), (unsigned) ret->id);
 
         if (_ret)
                 *_ret = ret;
@@ -1766,7 +1766,7 @@ Unit *manager_get_unit(Manager *m, const char *name) {
 }
 
 unsigned manager_dispatch_load_queue(Manager *m) {
-        Meta *meta;
+        Unit *meta;
         unsigned n = 0;
 
         assert(m);
@@ -1828,8 +1828,8 @@ int manager_load_unit_prepare(Manager *m, const char *name, const char *path, DB
                 return -ENOMEM;
 
         if (path) {
-                ret->meta.fragment_path = strdup(path);
-                if (!ret->meta.fragment_path) {
+                ret->fragment_path = strdup(path);
+                if (!ret->fragment_path) {
                         unit_free(ret);
                         return -ENOMEM;
                 }
@@ -1889,7 +1889,7 @@ void manager_dump_units(Manager *s, FILE *f, const char *prefix) {
         assert(f);
 
         HASHMAP_FOREACH_KEY(u, t, s->units, i)
-                if (u->meta.id == t)
+                if (u->id == t)
                         unit_dump(u, f, prefix);
 }
 
@@ -1927,7 +1927,7 @@ unsigned manager_dispatch_run_queue(Manager *m) {
 
 unsigned manager_dispatch_dbus_queue(Manager *m) {
         Job *j;
-        Meta *meta;
+        Unit *meta;
         unsigned n = 0;
 
         assert(m);
@@ -2014,7 +2014,7 @@ static int manager_process_notify_fd(Manager *m) {
                 if (!(tags = strv_split(buf, "\n\r")))
                         return -ENOMEM;
 
-                log_debug("Got notification message for unit %s", u->meta.id);
+                log_debug("Got notification message for unit %s", u->id);
 
                 if (UNIT_VTABLE(u)->notify_message)
                         UNIT_VTABLE(u)->notify_message(u, ucred->pid, tags);
@@ -2093,7 +2093,7 @@ static int manager_dispatch_sigchld(Manager *m) {
                 if (!u)
                         continue;
 
-                log_debug("Child %lu belongs to %s", (long unsigned) si.si_pid, u->meta.id);
+                log_debug("Child %lu belongs to %s", (long unsigned) si.si_pid, u->id);
 
                 hashmap_remove(m->watch_pids, LONG_TO_PTR(si.si_pid));
                 UNIT_VTABLE(u)->sigchld_event(u, si.si_pid, si.si_code, si.si_status);
@@ -2552,10 +2552,10 @@ void manager_send_unit_audit(Manager *m, Unit *u, int type, bool success) {
         if (m->running_as != MANAGER_SYSTEM)
                 return;
 
-        if (u->meta.type != UNIT_SERVICE)
+        if (u->type != UNIT_SERVICE)
                 return;
 
-        if (!(p = unit_name_to_prefix_and_instance(u->meta.id))) {
+        if (!(p = unit_name_to_prefix_and_instance(u->id))) {
                 log_error("Failed to allocate unit name for audit message: %s", strerror(ENOMEM));
                 return;
         }
@@ -2593,9 +2593,9 @@ void manager_send_unit_plymouth(Manager *m, Unit *u) {
         if (m->running_as != MANAGER_SYSTEM)
                 return;
 
-        if (u->meta.type != UNIT_SERVICE &&
-            u->meta.type != UNIT_MOUNT &&
-            u->meta.type != UNIT_SWAP)
+        if (u->type != UNIT_SERVICE &&
+            u->type != UNIT_MOUNT &&
+            u->type != UNIT_SWAP)
                 return;
 
         /* We set SOCK_NONBLOCK here so that we rather drop the
@@ -2621,7 +2621,7 @@ void manager_send_unit_plymouth(Manager *m, Unit *u) {
                 goto finish;
         }
 
-        if (asprintf(&message, "U\002%c%s%n", (int) (strlen(u->meta.id) + 1), u->meta.id, &n) < 0) {
+        if (asprintf(&message, "U\002%c%s%n", (int) (strlen(u->id) + 1), u->id, &n) < 0) {
                 log_error("Out of memory");
                 goto finish;
         }
@@ -2741,14 +2741,14 @@ int manager_serialize(Manager *m, FILE *f, FDSet *fds) {
         fputc('\n', f);
 
         HASHMAP_FOREACH_KEY(u, t, m->units, i) {
-                if (u->meta.id != t)
+                if (u->id != t)
                         continue;
 
                 if (!unit_can_serialize(u))
                         continue;
 
                 /* Start marker */
-                fputs(u->meta.id, f);
+                fputs(u->id, f);
                 fputc('\n', f);
 
                 if ((r = unit_serialize(u, f, fds)) < 0) {
@@ -2939,7 +2939,7 @@ bool manager_is_booting_or_shutting_down(Manager *m) {
         /* Is there a job for the shutdown target? */
         u = manager_get_unit(m, SPECIAL_SHUTDOWN_TARGET);
         if (u)
-                return !!u->meta.job;
+                return !!u->job;
 
         return false;
 }
diff --git a/src/manager.h b/src/manager.h
index 3455776..13c62da 100644
--- a/src/manager.h
+++ b/src/manager.h
@@ -74,7 +74,7 @@ struct Watch {
         int fd;
         WatchType type;
         union {
-                union Unit *unit;
+                struct Unit *unit;
                 struct Job *job;
                 DBusWatch *bus_watch;
                 DBusTimeout *bus_timeout;
@@ -102,10 +102,10 @@ struct Manager {
 
         /* To make it easy to iterate through the units of a specific
          * type we maintain a per type linked list */
-        LIST_HEAD(Meta, units_by_type[_UNIT_TYPE_MAX]);
+        LIST_HEAD(Unit, units_by_type[_UNIT_TYPE_MAX]);
 
         /* Units that need to be loaded */
-        LIST_HEAD(Meta, load_queue); /* this is actually more a stack than a queue, but uh. */
+        LIST_HEAD(Unit, load_queue); /* this is actually more a stack than a queue, but uh. */
 
         /* Jobs that need to be run */
         LIST_HEAD(Job, run_queue);   /* more a stack than a queue, too */
@@ -114,14 +114,14 @@ struct Manager {
          * D-Bus. When something about a job changes it is added here
          * if it is not in there yet. This allows easy coalescing of
          * D-Bus change signals. */
-        LIST_HEAD(Meta, dbus_unit_queue);
+        LIST_HEAD(Unit, dbus_unit_queue);
         LIST_HEAD(Job, dbus_job_queue);
 
         /* Units to remove */
-        LIST_HEAD(Meta, cleanup_queue);
+        LIST_HEAD(Unit, cleanup_queue);
 
         /* Units to check when doing GC */
-        LIST_HEAD(Meta, gc_queue);
+        LIST_HEAD(Unit, gc_queue);
 
         /* Jobs to be added */
         Hashmap *transaction_jobs;      /* Unit object => Job object list 1:1 */
diff --git a/src/mount.c b/src/mount.c
index 122f6d8..9e97309 100644
--- a/src/mount.c
+++ b/src/mount.c
@@ -59,7 +59,7 @@ static void mount_init(Unit *u) {
         Mount *m = MOUNT(u);
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         m->timeout_usec = DEFAULT_TIMEOUT_USEC;
         m->directory_mode = 0755;
@@ -69,8 +69,8 @@ static void mount_init(Unit *u) {
         /* The stdio/kmsg bridge socket is on /, in order to avoid a
          * dep loop, don't use kmsg logging for -.mount */
         if (!unit_has_name(u, "-.mount")) {
-                m->exec_context.std_output = u->meta.manager->default_std_output;
-                m->exec_context.std_error = u->meta.manager->default_std_error;
+                m->exec_context.std_output = u->manager->default_std_output;
+                m->exec_context.std_error = u->manager->default_std_error;
         }
 
         /* We need to make sure that /bin/mount is always called in
@@ -148,7 +148,7 @@ static MountParameters* get_mount_parameters(Mount *m) {
 }
 
 static int mount_add_mount_links(Mount *m) {
-        Meta *other;
+        Unit *other;
         int r;
         MountParameters *pm;
 
@@ -211,7 +211,7 @@ static int mount_add_mount_links(Mount *m) {
 }
 
 static int mount_add_swap_links(Mount *m) {
-        Meta *other;
+        Unit *other;
         int r;
 
         assert(m);
@@ -224,7 +224,7 @@ static int mount_add_swap_links(Mount *m) {
 }
 
 static int mount_add_path_links(Mount *m) {
-        Meta *other;
+        Unit *other;
         int r;
 
         assert(m);
@@ -237,7 +237,7 @@ static int mount_add_path_links(Mount *m) {
 }
 
 static int mount_add_automount_links(Mount *m) {
-        Meta *other;
+        Unit *other;
         int r;
 
         assert(m);
@@ -250,7 +250,7 @@ static int mount_add_automount_links(Mount *m) {
 }
 
 static int mount_add_socket_links(Mount *m) {
-        Meta *other;
+        Unit *other;
         int r;
 
         assert(m);
@@ -382,9 +382,9 @@ static int mount_add_fstab_links(Mount *m) {
 
                 /* Install automount unit */
                 if (!nofail) /* automount + fail */
-                        return unit_add_two_dependencies(tu, UNIT_AFTER, UNIT_REQUIRES, UNIT(am), true);
+                        return unit_add_two_dependencies(tu, UNIT_AFTER, UNIT_REQUIRES, am, true);
                 else /* automount + nofail */
-                        return unit_add_two_dependencies(tu, UNIT_AFTER, UNIT_WANTS, UNIT(am), true);
+                        return unit_add_two_dependencies(tu, UNIT_AFTER, UNIT_WANTS, am, true);
 
         } else if (handle && !noauto) {
 
@@ -422,13 +422,13 @@ static int mount_add_device_links(Mount *m) {
 
                 if ((r = unit_add_node_link(UNIT(m), p->what,
                                             !noauto && nofail &&
-                                            UNIT(m)->meta.manager->running_as == MANAGER_SYSTEM)) < 0)
+                                            UNIT(m)->manager->running_as == MANAGER_SYSTEM)) < 0)
                         return r;
         }
 
         if (p->passno > 0 &&
             !mount_is_bind(p) &&
-            UNIT(m)->meta.manager->running_as == MANAGER_SYSTEM &&
+            UNIT(m)->manager->running_as == MANAGER_SYSTEM &&
             !path_equal(m->where, "/")) {
                 char *name;
                 Unit *fsck;
@@ -517,10 +517,10 @@ static int mount_fix_timeouts(Mount *m) {
         }
 
         SET_FOREACH(other, m->meta.dependencies[UNIT_AFTER], i) {
-                if (other->meta.type != UNIT_DEVICE)
+                if (other->type != UNIT_DEVICE)
                         continue;
 
-                other->meta.job_timeout = u;
+                other->job_timeout = u;
         }
 
         return 0;
@@ -571,13 +571,13 @@ static int mount_load(Unit *u) {
         int r;
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         if ((r = unit_load_fragment_and_dropin_optional(u)) < 0)
                 return r;
 
         /* This is a new unit? Then let's add in some extras */
-        if (u->meta.load_state == UNIT_LOADED) {
+        if (u->load_state == UNIT_LOADED) {
                 if ((r = unit_add_exec_dependencies(u, &m->exec_context)) < 0)
                         return r;
 
@@ -590,7 +590,7 @@ static int mount_load(Unit *u) {
                         m->meta.default_dependencies = false;
 
                 if (!m->where)
-                        if (!(m->where = unit_name_to_path(u->meta.id)))
+                        if (!(m->where = unit_name_to_path(u->id)))
                                 return -ENOMEM;
 
                 path_kill_slashes(m->where);
@@ -641,7 +641,7 @@ static int mount_notify_automount(Mount *m, int status) {
         assert(m);
 
         SET_FOREACH(p, m->meta.dependencies[UNIT_TRIGGERED_BY], i)
-                if (p->meta.type == UNIT_AUTOMOUNT) {
+                if (p->type == UNIT_AUTOMOUNT) {
                          r = automount_send_ready(AUTOMOUNT(p), status);
                          if (r < 0)
                                  return r;
@@ -1225,7 +1225,7 @@ static void mount_sigchld_event(Unit *u, pid_t pid, int code, int status) {
         }
 
         log_full(success ? LOG_DEBUG : LOG_NOTICE,
-                 "%s mount process exited, code=%s status=%i", u->meta.id, sigchld_code_to_string(code), status);
+                 "%s mount process exited, code=%s status=%i", u->id, sigchld_code_to_string(code), status);
 
         /* Note that mount(8) returning and the kernel sending us a
          * mount table change event might happen out-of-order. If an
@@ -1292,27 +1292,27 @@ static void mount_timer_event(Unit *u, uint64_t elapsed, Watch *w) {
 
         case MOUNT_MOUNTING:
         case MOUNT_MOUNTING_DONE:
-                log_warning("%s mounting timed out. Stopping.", u->meta.id);
+                log_warning("%s mounting timed out. Stopping.", u->id);
                 mount_enter_signal(m, MOUNT_MOUNTING_SIGTERM, false);
                 break;
 
         case MOUNT_REMOUNTING:
-                log_warning("%s remounting timed out. Stopping.", u->meta.id);
+                log_warning("%s remounting timed out. Stopping.", u->id);
                 m->reload_failure = true;
                 mount_enter_mounted(m, true);
                 break;
 
         case MOUNT_UNMOUNTING:
-                log_warning("%s unmounting timed out. Stopping.", u->meta.id);
+                log_warning("%s unmounting timed out. Stopping.", u->id);
                 mount_enter_signal(m, MOUNT_UNMOUNTING_SIGTERM, false);
                 break;
 
         case MOUNT_MOUNTING_SIGTERM:
                 if (m->exec_context.send_sigkill) {
-                        log_warning("%s mounting timed out. Killing.", u->meta.id);
+                        log_warning("%s mounting timed out. Killing.", u->id);
                         mount_enter_signal(m, MOUNT_MOUNTING_SIGKILL, false);
                 } else {
-                        log_warning("%s mounting timed out. Skipping SIGKILL. Ignoring.", u->meta.id);
+                        log_warning("%s mounting timed out. Skipping SIGKILL. Ignoring.", u->id);
 
                         if (m->from_proc_self_mountinfo)
                                 mount_enter_mounted(m, false);
@@ -1323,10 +1323,10 @@ static void mount_timer_event(Unit *u, uint64_t elapsed, Watch *w) {
 
         case MOUNT_REMOUNTING_SIGTERM:
                 if (m->exec_context.send_sigkill) {
-                        log_warning("%s remounting timed out. Killing.", u->meta.id);
+                        log_warning("%s remounting timed out. Killing.", u->id);
                         mount_enter_signal(m, MOUNT_REMOUNTING_SIGKILL, false);
                 } else {
-                        log_warning("%s remounting timed out. Skipping SIGKILL. Ignoring.", u->meta.id);
+                        log_warning("%s remounting timed out. Skipping SIGKILL. Ignoring.", u->id);
 
                         if (m->from_proc_self_mountinfo)
                                 mount_enter_mounted(m, false);
@@ -1337,10 +1337,10 @@ static void mount_timer_event(Unit *u, uint64_t elapsed, Watch *w) {
 
         case MOUNT_UNMOUNTING_SIGTERM:
                 if (m->exec_context.send_sigkill) {
-                        log_warning("%s unmounting timed out. Killing.", u->meta.id);
+                        log_warning("%s unmounting timed out. Killing.", u->id);
                         mount_enter_signal(m, MOUNT_UNMOUNTING_SIGKILL, false);
                 } else {
-                        log_warning("%s unmounting timed out. Skipping SIGKILL. Ignoring.", u->meta.id);
+                        log_warning("%s unmounting timed out. Skipping SIGKILL. Ignoring.", u->id);
 
                         if (m->from_proc_self_mountinfo)
                                 mount_enter_mounted(m, false);
@@ -1352,7 +1352,7 @@ static void mount_timer_event(Unit *u, uint64_t elapsed, Watch *w) {
         case MOUNT_MOUNTING_SIGKILL:
         case MOUNT_REMOUNTING_SIGKILL:
         case MOUNT_UNMOUNTING_SIGKILL:
-                log_warning("%s mount process still around after SIGKILL. Ignoring.", u->meta.id);
+                log_warning("%s mount process still around after SIGKILL. Ignoring.", u->id);
 
                 if (m->from_proc_self_mountinfo)
                         mount_enter_mounted(m, false);
@@ -1684,7 +1684,7 @@ fail:
 }
 
 void mount_fd_event(Manager *m, int events) {
-        Meta *meta;
+        Unit *meta;
         int r;
 
         assert(m);
diff --git a/src/mount.h b/src/mount.h
index 7c5d9d1..730c4c27 100644
--- a/src/mount.h
+++ b/src/mount.h
@@ -60,7 +60,7 @@ typedef struct MountParameters {
 } MountParameters;
 
 struct Mount {
-        Meta meta;
+        Unit meta;
 
         char *where;
 
diff --git a/src/path.c b/src/path.c
index ae5052a..bfb5cdf 100644
--- a/src/path.c
+++ b/src/path.c
@@ -236,7 +236,7 @@ static void path_init(Unit *u) {
         Path *p = PATH(u);
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         p->directory_mode = 0755;
 }
@@ -281,7 +281,7 @@ int path_add_one_mount_link(Path *p, Mount *m) {
 }
 
 static int path_add_mount_links(Path *p) {
-        Meta *other;
+        Unit *other;
         int r;
 
         assert(p);
@@ -328,12 +328,12 @@ static int path_load(Unit *u) {
         int r;
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         if ((r = unit_load_fragment_and_dropin(u)) < 0)
                 return r;
 
-        if (u->meta.load_state == UNIT_LOADED) {
+        if (u->load_state == UNIT_LOADED) {
 
                 if (!UNIT_DEREF(p->unit)) {
                         Unit *x;
@@ -373,7 +373,7 @@ static void path_dump(Unit *u, FILE *f, const char *prefix) {
                 "%sMakeDirectory: %s\n"
                 "%sDirectoryMode: %04o\n",
                 prefix, path_state_to_string(p->state),
-                prefix, UNIT_DEREF(p->unit)->meta.id,
+                prefix, UNIT_DEREF(p->unit)->id,
                 prefix, yes_no(p->make_directory),
                 prefix, p->directory_mode);
 
@@ -547,7 +547,7 @@ static int path_start(Unit *u) {
         assert(p);
         assert(p->state == PATH_DEAD || p->state == PATH_FAILED);
 
-        if (UNIT_DEREF(p->unit)->meta.load_state != UNIT_LOADED)
+        if (UNIT_DEREF(p->unit)->load_state != UNIT_LOADED)
                 return -ENOENT;
 
         path_mkdir(p);
@@ -625,7 +625,7 @@ static void path_fd_event(Unit *u, int fd, uint32_t events, Watch *w) {
             p->state != PATH_RUNNING)
                 return;
 
-        /* log_debug("inotify wakeup on %s.", u->meta.id); */
+        /* log_debug("inotify wakeup on %s.", u->id); */
 
         LIST_FOREACH(spec, s, p->specs)
                 if (path_spec_owns_inotify_fd(s, fd))
@@ -660,16 +660,16 @@ void path_unit_notify(Unit *u, UnitActiveState new_state) {
         Iterator i;
         Unit *k;
 
-        if (u->meta.type == UNIT_PATH)
+        if (u->type == UNIT_PATH)
                 return;
 
-        SET_FOREACH(k, u->meta.dependencies[UNIT_TRIGGERED_BY], i) {
+        SET_FOREACH(k, u->dependencies[UNIT_TRIGGERED_BY], i) {
                 Path *p;
 
-                if (k->meta.type != UNIT_PATH)
+                if (k->type != UNIT_PATH)
                         continue;
 
-                if (k->meta.load_state != UNIT_LOADED)
+                if (k->load_state != UNIT_LOADED)
                         continue;
 
                 p = PATH(k);
diff --git a/src/path.h b/src/path.h
index 8b3c0bc..04d43c8 100644
--- a/src/path.h
+++ b/src/path.h
@@ -70,7 +70,7 @@ static inline bool path_spec_owns_inotify_fd(PathSpec *s, int fd) {
 }
 
 struct Path {
-        Meta meta;
+        Unit meta;
 
         LIST_HEAD(PathSpec, specs);
 
diff --git a/src/service.c b/src/service.c
index be99951..ab6e1ea 100644
--- a/src/service.c
+++ b/src/service.c
@@ -109,7 +109,7 @@ static void service_init(Unit *u) {
         Service *s = SERVICE(u);
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         s->timeout_usec = DEFAULT_TIMEOUT_USEC;
         s->restart_usec = DEFAULT_RESTART_USEC;
@@ -237,7 +237,7 @@ static void service_done(Unit *u) {
         service_unwatch_pid_file(s);
 
         if (s->bus_name)  {
-                unit_unwatch_bus_name(UNIT(u), s->bus_name);
+                unit_unwatch_bus_name(u, s->bus_name);
                 free(s->bus_name);
                 s->bus_name = NULL;
         }
@@ -372,7 +372,7 @@ finish:
 }
 
 static int sysv_fix_order(Service *s) {
-        Meta *other;
+        Unit *other;
         int r;
 
         assert(s);
@@ -508,7 +508,7 @@ static int service_load_sysv_path(Service *s, const char *path) {
         s->sysv_mtime = timespec_load(&st.st_mtim);
 
         if (null_or_empty(&st)) {
-                u->meta.load_state = UNIT_MASKED;
+                u->load_state = UNIT_MASKED;
                 r = 0;
                 goto finish;
         }
@@ -870,7 +870,7 @@ static int service_load_sysv_path(Service *s, const char *path) {
                         goto finish;
                 }
 
-                u->meta.description = d;
+                u->description = d;
         }
 
         /* The priority that has been set in /etc/rcN.d/ hierarchies
@@ -879,7 +879,7 @@ static int service_load_sysv_path(Service *s, const char *path) {
         if (s->sysv_start_priority_from_rcnd >= 0)
                 s->sysv_start_priority = s->sysv_start_priority_from_rcnd;
 
-        u->meta.load_state = UNIT_LOADED;
+        u->load_state = UNIT_LOADED;
         r = 0;
 
 finish:
@@ -1013,7 +1013,7 @@ static int service_load_sysv(Service *s) {
 #endif
 
 static int fsck_fix_order(Service *s) {
-        Meta *other;
+        Unit *other;
         int r;
 
         assert(s);
@@ -1143,13 +1143,13 @@ static int service_load(Unit *u) {
 
 #ifdef HAVE_SYSV_COMPAT
         /* Load a classic init script as a fallback, if we couldn't find anything */
-        if (u->meta.load_state == UNIT_STUB)
+        if (u->load_state == UNIT_STUB)
                 if ((r = service_load_sysv(s)) < 0)
                         return r;
 #endif
 
         /* Still nothing found? Then let's give up */
-        if (u->meta.load_state == UNIT_STUB)
+        if (u->load_state == UNIT_STUB)
                 return -ENOENT;
 
         /* We were able to load something, then let's add in the
@@ -1158,7 +1158,7 @@ static int service_load(Unit *u) {
                 return r;
 
         /* This is a new unit? Then let's add in some extras */
-        if (u->meta.load_state == UNIT_LOADED) {
+        if (u->load_state == UNIT_LOADED) {
                 service_fix_output(s);
 
                 if ((r = unit_add_exec_dependencies(u, &s->exec_context)) < 0)
@@ -1388,7 +1388,7 @@ static void service_notify_sockets_dead(Service *s, bool failed_permanent) {
                 return;
 
         SET_FOREACH(u, s->meta.dependencies[UNIT_TRIGGERED_BY], i)
-                if (u->meta.type == UNIT_SOCKET)
+                if (u->type == UNIT_SOCKET)
                         socket_notify_service_dead(SOCKET(u), failed_permanent);
 
         return;
@@ -1566,7 +1566,7 @@ static int service_collect_fds(Service *s, int **fds, unsigned *n_fds) {
                 unsigned cn_fds;
                 Socket *sock;
 
-                if (u->meta.type != UNIT_SOCKET)
+                if (u->type != UNIT_SOCKET)
                         continue;
 
                 sock = SOCKET(u);
@@ -2275,7 +2275,7 @@ static int service_start(Unit *u) {
 
         /* Make sure we don't enter a busy loop of some kind. */
         if (!ratelimit_test(&s->ratelimit)) {
-                log_warning("%s start request repeated too quickly, refusing to start.", u->meta.id);
+                log_warning("%s start request repeated too quickly, refusing to start.", u->id);
                 service_notify_sockets_dead(s, true);
                 return -ECANCELED;
         }
@@ -2613,7 +2613,7 @@ static void service_fd_event(Unit *u, int fd, uint32_t events, Watch *w) {
         assert(s->pid_file_pathspec);
         assert(path_spec_owns_inotify_fd(s->pid_file_pathspec, fd));
 
-        log_debug("inotify event for %s", u->meta.id);
+        log_debug("inotify event for %s", u->id);
 
         if (path_spec_fd_event(s->pid_file_pathspec, events) < 0)
                 goto fail;
@@ -2664,7 +2664,7 @@ static void service_sigchld_event(Unit *u, pid_t pid, int code, int status) {
                 }
 
                 log_full(success ? LOG_DEBUG : LOG_NOTICE,
-                         "%s: main process exited, code=%s, status=%i", u->meta.id, sigchld_code_to_string(code), status);
+                         "%s: main process exited, code=%s, status=%i", u->id, sigchld_code_to_string(code), status);
                 s->failure = s->failure || !success;
 
                 if (s->main_command &&
@@ -2674,7 +2674,7 @@ static void service_sigchld_event(Unit *u, pid_t pid, int code, int status) {
                         /* There is another command to *
                          * execute, so let's do that. */
 
-                        log_debug("%s running next main command for state %s", u->meta.id, service_state_to_string(s->state));
+                        log_debug("%s running next main command for state %s", u->id, service_state_to_string(s->state));
                         service_run_next_main(s, success);
 
                 } else {
@@ -2736,7 +2736,7 @@ static void service_sigchld_event(Unit *u, pid_t pid, int code, int status) {
                 }
 
                 log_full(success ? LOG_DEBUG : LOG_NOTICE,
-                         "%s: control process exited, code=%s status=%i", u->meta.id, sigchld_code_to_string(code), status);
+                         "%s: control process exited, code=%s status=%i", u->id, sigchld_code_to_string(code), status);
                 s->failure = s->failure || !success;
 
                 if (s->control_command &&
@@ -2746,7 +2746,7 @@ static void service_sigchld_event(Unit *u, pid_t pid, int code, int status) {
                         /* There is another command to *
                          * execute, so let's do that. */
 
-                        log_debug("%s running next control command for state %s", u->meta.id, service_state_to_string(s->state));
+                        log_debug("%s running next control command for state %s", u->id, service_state_to_string(s->state));
                         service_run_next_control(s, success);
 
                 } else {
@@ -2756,7 +2756,7 @@ static void service_sigchld_event(Unit *u, pid_t pid, int code, int status) {
                         s->control_command = NULL;
                         s->control_command_id = _SERVICE_EXEC_COMMAND_INVALID;
 
-                        log_debug("%s got final SIGCHLD for state %s", u->meta.id, service_state_to_string(s->state));
+                        log_debug("%s got final SIGCHLD for state %s", u->id, service_state_to_string(s->state));
 
                         switch (s->state) {
 
@@ -2865,32 +2865,32 @@ static void service_timer_event(Unit *u, uint64_t elapsed, Watch* w) {
 
         case SERVICE_START_PRE:
         case SERVICE_START:
-                log_warning("%s operation timed out. Terminating.", u->meta.id);
+                log_warning("%s operation timed out. Terminating.", u->id);
                 service_enter_signal(s, SERVICE_FINAL_SIGTERM, false);
                 break;
 
         case SERVICE_START_POST:
-                log_warning("%s operation timed out. Stopping.", u->meta.id);
+                log_warning("%s operation timed out. Stopping.", u->id);
                 service_enter_stop(s, false);
                 break;
 
         case SERVICE_RELOAD:
-                log_warning("%s operation timed out. Stopping.", u->meta.id);
+                log_warning("%s operation timed out. Stopping.", u->id);
                 s->reload_failure = true;
                 service_enter_running(s, true);
                 break;
 
         case SERVICE_STOP:
-                log_warning("%s stopping timed out. Terminating.", u->meta.id);
+                log_warning("%s stopping timed out. Terminating.", u->id);
                 service_enter_signal(s, SERVICE_STOP_SIGTERM, false);
                 break;
 
         case SERVICE_STOP_SIGTERM:
                 if (s->exec_context.send_sigkill) {
-                        log_warning("%s stopping timed out. Killing.", u->meta.id);
+                        log_warning("%s stopping timed out. Killing.", u->id);
                         service_enter_signal(s, SERVICE_STOP_SIGKILL, false);
                 } else {
-                        log_warning("%s stopping timed out. Skipping SIGKILL.", u->meta.id);
+                        log_warning("%s stopping timed out. Skipping SIGKILL.", u->id);
                         service_enter_stop_post(s, false);
                 }
 
@@ -2901,33 +2901,33 @@ static void service_timer_event(Unit *u, uint64_t elapsed, Watch* w) {
                  * Must be something we cannot kill, so let's just be
                  * weirded out and continue */
 
-                log_warning("%s still around after SIGKILL. Ignoring.", u->meta.id);
+                log_warning("%s still around after SIGKILL. Ignoring.", u->id);
                 service_enter_stop_post(s, false);
                 break;
 
         case SERVICE_STOP_POST:
-                log_warning("%s stopping timed out (2). Terminating.", u->meta.id);
+                log_warning("%s stopping timed out (2). Terminating.", u->id);
                 service_enter_signal(s, SERVICE_FINAL_SIGTERM, false);
                 break;
 
         case SERVICE_FINAL_SIGTERM:
                 if (s->exec_context.send_sigkill) {
-                        log_warning("%s stopping timed out (2). Killing.", u->meta.id);
+                        log_warning("%s stopping timed out (2). Killing.", u->id);
                         service_enter_signal(s, SERVICE_FINAL_SIGKILL, false);
                 } else {
-                        log_warning("%s stopping timed out (2). Skipping SIGKILL. Entering failed mode.", u->meta.id);
+                        log_warning("%s stopping timed out (2). Skipping SIGKILL. Entering failed mode.", u->id);
                         service_enter_dead(s, false, true);
                 }
 
                 break;
 
         case SERVICE_FINAL_SIGKILL:
-                log_warning("%s still around after SIGKILL (2). Entering failed mode.", u->meta.id);
+                log_warning("%s still around after SIGKILL (2). Entering failed mode.", u->id);
                 service_enter_dead(s, false, true);
                 break;
 
         case SERVICE_AUTO_RESTART:
-                log_info("%s holdoff time over, scheduling restart.", u->meta.id);
+                log_info("%s holdoff time over, scheduling restart.", u->id);
                 service_enter_restart(s);
                 break;
 
@@ -2941,7 +2941,7 @@ static void service_cgroup_notify_event(Unit *u) {
 
         assert(u);
 
-        log_debug("%s: cgroup is empty", u->meta.id);
+        log_debug("%s: cgroup is empty", u->id);
 
         switch (s->state) {
 
@@ -2997,17 +2997,17 @@ static void service_notify_message(Unit *u, pid_t pid, char **tags) {
 
         if (s->notify_access == NOTIFY_NONE) {
                 log_warning("%s: Got notification message from PID %lu, but reception is disabled.",
-                            u->meta.id, (unsigned long) pid);
+                            u->id, (unsigned long) pid);
                 return;
         }
 
         if (s->notify_access == NOTIFY_MAIN && pid != s->main_pid) {
                 log_warning("%s: Got notification message from PID %lu, but reception only permitted for PID %lu",
-                            u->meta.id, (unsigned long) pid, (unsigned long) s->main_pid);
+                            u->id, (unsigned long) pid, (unsigned long) s->main_pid);
                 return;
         }
 
-        log_debug("%s: Got message", u->meta.id);
+        log_debug("%s: Got message", u->id);
 
         /* Interpret MAINPID= */
         if ((e = strv_find_prefix(tags, "MAINPID=")) &&
@@ -3019,7 +3019,7 @@ static void service_notify_message(Unit *u, pid_t pid, char **tags) {
                 if (parse_pid(e + 8, &pid) < 0)
                         log_warning("Failed to parse notification message %s", e);
                 else {
-                        log_debug("%s: got %s", u->meta.id, e);
+                        log_debug("%s: got %s", u->id, e);
                         service_set_main_pid(s, pid);
                 }
         }
@@ -3028,7 +3028,7 @@ static void service_notify_message(Unit *u, pid_t pid, char **tags) {
         if (s->type == SERVICE_NOTIFY &&
             s->state == SERVICE_START &&
             strv_find(tags, "READY=1")) {
-                log_debug("%s: got READY=1", u->meta.id);
+                log_debug("%s: got READY=1", u->id);
 
                 service_enter_start_post(s);
         }
@@ -3051,7 +3051,7 @@ static void service_notify_message(Unit *u, pid_t pid, char **tags) {
                                 return;
                         }
 
-                        log_debug("%s: got %s", u->meta.id, e);
+                        log_debug("%s: got %s", u->id, e);
 
                         free(s->status_text);
                         s->status_text = t;
@@ -3102,7 +3102,7 @@ static void sysv_facility_in_insserv_conf(Manager *mgr) {
                         Unit *u;
                         if (sysv_translate_facility(parsed[0], NULL, &facility) < 0)
                                 continue;
-                        if ((u = manager_get_unit(mgr, facility)) && (u->meta.type == UNIT_TARGET)) {
+                        if ((u = manager_get_unit(mgr, facility)) && (u->type == UNIT_TARGET)) {
                                 UnitDependency e;
                                 char *dep = NULL, *name, **j;
 
@@ -3255,7 +3255,7 @@ static int service_enumerate(Manager *m) {
                 SET_FOREACH(service, runlevel_services[i], j) {
                         service = unit_follow_merge(service);
 
-                        if (service->meta.fragment_path)
+                        if (service->fragment_path)
                                 continue;
 
                         if ((r = unit_add_two_dependencies_by_name_inverse(service, UNIT_AFTER, UNIT_WANTS, rcnd_table[i].target, NULL, true)) < 0)
@@ -3272,7 +3272,7 @@ static int service_enumerate(Manager *m) {
         SET_FOREACH(service, shutdown_services, j) {
                 service = unit_follow_merge(service);
 
-                if (service->meta.fragment_path)
+                if (service->fragment_path)
                         continue;
 
                 if ((r = unit_add_two_dependencies_by_name(service, UNIT_BEFORE, UNIT_CONFLICTS, SPECIAL_SHUTDOWN_TARGET, NULL, true)) < 0)
@@ -3316,11 +3316,11 @@ static void service_bus_name_owner_change(
         assert(old_owner || new_owner);
 
         if (old_owner && new_owner)
-                log_debug("%s's D-Bus name %s changed owner from %s to %s", u->meta.id, name, old_owner, new_owner);
+                log_debug("%s's D-Bus name %s changed owner from %s to %s", u->id, name, old_owner, new_owner);
         else if (old_owner)
-                log_debug("%s's D-Bus name %s no longer registered by %s", u->meta.id, name, old_owner);
+                log_debug("%s's D-Bus name %s no longer registered by %s", u->id, name, old_owner);
         else
-                log_debug("%s's D-Bus name %s now registered by %s", u->meta.id, name, new_owner);
+                log_debug("%s's D-Bus name %s now registered by %s", u->id, name, new_owner);
 
         s->bus_name_good = !!new_owner;
 
@@ -3343,7 +3343,7 @@ static void service_bus_name_owner_change(
                 /* Try to acquire PID from bus service */
                 log_debug("Trying to acquire PID from D-Bus name...");
 
-                bus_query_pid(u->meta.manager, name);
+                bus_query_pid(u->manager, name);
         }
 }
 
@@ -3357,7 +3357,7 @@ static void service_bus_query_pid_done(
         assert(s);
         assert(name);
 
-        log_debug("%s's D-Bus name %s is now owned by process %u", u->meta.id, name, (unsigned) pid);
+        log_debug("%s's D-Bus name %s is now owned by process %u", u->id, name, (unsigned) pid);
 
         if (s->main_pid <= 0 &&
             (s->state == SERVICE_START ||
diff --git a/src/service.h b/src/service.h
index 8f67ad5..0b4f8be 100644
--- a/src/service.h
+++ b/src/service.h
@@ -89,7 +89,7 @@ typedef enum NotifyAccess {
 } NotifyAccess;
 
 struct Service {
-        Meta meta;
+        Unit meta;
 
         ServiceType type;
         ServiceRestart restart;
diff --git a/src/snapshot.c b/src/snapshot.c
index 161629d..bc1388c 100644
--- a/src/snapshot.c
+++ b/src/snapshot.c
@@ -62,14 +62,14 @@ static int snapshot_load(Unit *u) {
         Snapshot *s = SNAPSHOT(u);
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         /* Make sure that only snapshots created via snapshot_create()
          * can be loaded */
         if (!s->by_snapshot_create && s->meta.manager->n_reloading <= 0)
                 return -ENOENT;
 
-        u->meta.load_state = UNIT_LOADED;
+        u->load_state = UNIT_LOADED;
         return 0;
 }
 
@@ -133,8 +133,8 @@ static int snapshot_serialize(Unit *u, FILE *f, FDSet *fds) {
 
         unit_serialize_item(u, f, "state", snapshot_state_to_string(s->state));
         unit_serialize_item(u, f, "cleanup", yes_no(s->cleanup));
-        SET_FOREACH(other, u->meta.dependencies[UNIT_WANTS], i)
-                unit_serialize_item(u, f, "wants", other->meta.id);
+        SET_FOREACH(other, u->dependencies[UNIT_WANTS], i)
+                unit_serialize_item(u, f, "wants", other->id);
 
         return 0;
 }
@@ -234,14 +234,14 @@ int snapshot_create(Manager *m, const char *name, bool cleanup, DBusError *e, Sn
 
         SNAPSHOT(u)->by_snapshot_create = true;
         manager_dispatch_load_queue(m);
-        assert(u->meta.load_state == UNIT_LOADED);
+        assert(u->load_state == UNIT_LOADED);
 
         HASHMAP_FOREACH_KEY(other, k, m->units, i) {
 
-                if (other->meta.ignore_on_snapshot)
+                if (other->ignore_on_snapshot)
                         continue;
 
-                if (k != other->meta.id)
+                if (k != other->id)
                         continue;
 
                 if (UNIT_VTABLE(other)->check_snapshot)
diff --git a/src/snapshot.h b/src/snapshot.h
index 9a30520..bf92e99 100644
--- a/src/snapshot.h
+++ b/src/snapshot.h
@@ -34,7 +34,7 @@ typedef enum SnapshotState {
 } SnapshotState;
 
 struct Snapshot {
-        Meta meta;
+        Unit meta;
 
         SnapshotState state, deserialized_state;
 
diff --git a/src/socket.c b/src/socket.c
index a57548d..0cb142b 100644
--- a/src/socket.c
+++ b/src/socket.c
@@ -64,7 +64,7 @@ static void socket_init(Unit *u) {
         Socket *s = SOCKET(u);
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         s->backlog = SOMAXCONN;
         s->timeout_usec = DEFAULT_TIMEOUT_USEC;
@@ -79,8 +79,8 @@ static void socket_init(Unit *u) {
         s->mark = -1;
 
         exec_context_init(&s->exec_context);
-        s->exec_context.std_output = u->meta.manager->default_std_output;
-        s->exec_context.std_error = u->meta.manager->default_std_error;
+        s->exec_context.std_output = u->manager->default_std_output;
+        s->exec_context.std_error = u->manager->default_std_error;
 
         s->control_command_id = _SOCKET_EXEC_COMMAND_INVALID;
 }
@@ -169,7 +169,7 @@ static int socket_instantiate_service(Socket *s) {
         }
 #endif
 
-        u->meta.no_gc = true;
+        u->no_gc = true;
         unit_ref_set(&s->service, u);
 
         return unit_add_two_dependencies(UNIT(s), UNIT_BEFORE, UNIT_TRIGGERS, u, false);
@@ -268,7 +268,7 @@ int socket_add_one_mount_link(Socket *s, Mount *m) {
 }
 
 static int socket_add_mount_links(Socket *s) {
-        Meta *other;
+        Unit *other;
         int r;
 
         assert(s);
@@ -329,13 +329,13 @@ static int socket_load(Unit *u) {
         int r;
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         if ((r = unit_load_fragment_and_dropin(u)) < 0)
                 return r;
 
         /* This is a new unit? Then let's add in some extras */
-        if (u->meta.load_state == UNIT_LOADED) {
+        if (u->load_state == UNIT_LOADED) {
 
                 if (have_non_accept_socket(s)) {
 
@@ -1806,14 +1806,14 @@ static void socket_fd_event(Unit *u, int fd, uint32_t events, Watch *w) {
         if (s->state != SOCKET_LISTENING)
                 return;
 
-        log_debug("Incoming traffic on %s", u->meta.id);
+        log_debug("Incoming traffic on %s", u->id);
 
         if (events != EPOLLIN) {
 
                 if (events & EPOLLHUP)
-                        log_error("%s: Got POLLHUP on a listening socket. The service probably invoked shutdown() on it, and should better not do that.", u->meta.id);
+                        log_error("%s: Got POLLHUP on a listening socket. The service probably invoked shutdown() on it, and should better not do that.", u->id);
                 else
-                        log_error("%s: Got unexpected poll event (0x%x) on socket.", u->meta.id, events);
+                        log_error("%s: Got unexpected poll event (0x%x) on socket.", u->id, events);
 
                 goto fail;
         }
@@ -1865,11 +1865,11 @@ static void socket_sigchld_event(Unit *u, pid_t pid, int code, int status) {
         }
 
         log_full(success ? LOG_DEBUG : LOG_NOTICE,
-                 "%s control process exited, code=%s status=%i", u->meta.id, sigchld_code_to_string(code), status);
+                 "%s control process exited, code=%s status=%i", u->id, sigchld_code_to_string(code), status);
         s->failure = s->failure || !success;
 
         if (s->control_command && s->control_command->command_next && success) {
-                log_debug("%s running next command for state %s", u->meta.id, socket_state_to_string(s->state));
+                log_debug("%s running next command for state %s", u->id, socket_state_to_string(s->state));
                 socket_run_next(s, success);
         } else {
                 s->control_command = NULL;
@@ -1878,7 +1878,7 @@ static void socket_sigchld_event(Unit *u, pid_t pid, int code, int status) {
                 /* No further commands for this step, so let's figure
                  * out what to do next */
 
-                log_debug("%s got final SIGCHLD for state %s", u->meta.id, socket_state_to_string(s->state));
+                log_debug("%s got final SIGCHLD for state %s", u->id, socket_state_to_string(s->state));
 
                 switch (s->state) {
 
@@ -1927,52 +1927,52 @@ static void socket_timer_event(Unit *u, uint64_t elapsed, Watch *w) {
         switch (s->state) {
 
         case SOCKET_START_PRE:
-                log_warning("%s starting timed out. Terminating.", u->meta.id);
+                log_warning("%s starting timed out. Terminating.", u->id);
                 socket_enter_signal(s, SOCKET_FINAL_SIGTERM, false);
                 break;
 
         case SOCKET_START_POST:
-                log_warning("%s starting timed out. Stopping.", u->meta.id);
+                log_warning("%s starting timed out. Stopping.", u->id);
                 socket_enter_stop_pre(s, false);
                 break;
 
         case SOCKET_STOP_PRE:
-                log_warning("%s stopping timed out. Terminating.", u->meta.id);
+                log_warning("%s stopping timed out. Terminating.", u->id);
                 socket_enter_signal(s, SOCKET_STOP_PRE_SIGTERM, false);
                 break;
 
         case SOCKET_STOP_PRE_SIGTERM:
                 if (s->exec_context.send_sigkill) {
-                        log_warning("%s stopping timed out. Killing.", u->meta.id);
+                        log_warning("%s stopping timed out. Killing.", u->id);
                         socket_enter_signal(s, SOCKET_STOP_PRE_SIGKILL, false);
                 } else {
-                        log_warning("%s stopping timed out. Skipping SIGKILL. Ignoring.", u->meta.id);
+                        log_warning("%s stopping timed out. Skipping SIGKILL. Ignoring.", u->id);
                         socket_enter_stop_post(s, false);
                 }
                 break;
 
         case SOCKET_STOP_PRE_SIGKILL:
-                log_warning("%s still around after SIGKILL. Ignoring.", u->meta.id);
+                log_warning("%s still around after SIGKILL. Ignoring.", u->id);
                 socket_enter_stop_post(s, false);
                 break;
 
         case SOCKET_STOP_POST:
-                log_warning("%s stopping timed out (2). Terminating.", u->meta.id);
+                log_warning("%s stopping timed out (2). Terminating.", u->id);
                 socket_enter_signal(s, SOCKET_FINAL_SIGTERM, false);
                 break;
 
         case SOCKET_FINAL_SIGTERM:
                 if (s->exec_context.send_sigkill) {
-                        log_warning("%s stopping timed out (2). Killing.", u->meta.id);
+                        log_warning("%s stopping timed out (2). Killing.", u->id);
                         socket_enter_signal(s, SOCKET_FINAL_SIGKILL, false);
                 } else {
-                        log_warning("%s stopping timed out (2). Skipping SIGKILL. Ignoring.", u->meta.id);
+                        log_warning("%s stopping timed out (2). Skipping SIGKILL. Ignoring.", u->id);
                         socket_enter_dead(s, false);
                 }
                 break;
 
         case SOCKET_FINAL_SIGKILL:
-                log_warning("%s still around after SIGKILL (2). Entering failed mode.", u->meta.id);
+                log_warning("%s still around after SIGKILL (2). Entering failed mode.", u->id);
                 socket_enter_dead(s, false);
                 break;
 
diff --git a/src/socket.h b/src/socket.h
index b172402..26d3058 100644
--- a/src/socket.h
+++ b/src/socket.h
@@ -77,7 +77,7 @@ typedef struct SocketPort {
 } SocketPort;
 
 struct Socket {
-        Meta meta;
+        Unit meta;
 
         LIST_HEAD(SocketPort, ports);
 
diff --git a/src/swap.c b/src/swap.c
index 202c4e6..87be552 100644
--- a/src/swap.c
+++ b/src/swap.c
@@ -83,8 +83,8 @@ static void swap_init(Unit *u) {
         s->timeout_usec = DEFAULT_TIMEOUT_USEC;
 
         exec_context_init(&s->exec_context);
-        s->exec_context.std_output = u->meta.manager->default_std_output;
-        s->exec_context.std_error = u->meta.manager->default_std_error;
+        s->exec_context.std_output = u->manager->default_std_output;
+        s->exec_context.std_error = u->manager->default_std_error;
 
         s->parameters_etc_fstab.priority = s->parameters_proc_swaps.priority = s->parameters_fragment.priority = -1;
 
@@ -151,7 +151,7 @@ int swap_add_one_mount_link(Swap *s, Mount *m) {
 }
 
 static int swap_add_mount_links(Swap *s) {
-        Meta *other;
+        Unit *other;
         int r;
 
         assert(s);
@@ -262,13 +262,13 @@ static int swap_load(Unit *u) {
         Swap *s = SWAP(u);
 
         assert(s);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         /* Load a .swap file */
         if ((r = unit_load_fragment_and_dropin_optional(u)) < 0)
                 return r;
 
-        if (u->meta.load_state == UNIT_LOADED) {
+        if (u->load_state == UNIT_LOADED) {
                 if ((r = unit_add_exec_dependencies(u, &s->exec_context)) < 0)
                         return r;
 
@@ -283,7 +283,7 @@ static int swap_load(Unit *u) {
                         else if (s->parameters_proc_swaps.what)
                                 s->what = strdup(s->parameters_proc_swaps.what);
                         else
-                                s->what = unit_name_to_path(u->meta.id);
+                                s->what = unit_name_to_path(u->id);
 
                         if (!s->what)
                                 return -ENOMEM;
@@ -952,7 +952,7 @@ static void swap_sigchld_event(Unit *u, pid_t pid, int code, int status) {
         }
 
         log_full(success ? LOG_DEBUG : LOG_NOTICE,
-                 "%s swap process exited, code=%s status=%i", u->meta.id, sigchld_code_to_string(code), status);
+                 "%s swap process exited, code=%s status=%i", u->id, sigchld_code_to_string(code), status);
 
         switch (s->state) {
 
@@ -985,7 +985,7 @@ static void swap_sigchld_event(Unit *u, pid_t pid, int code, int status) {
 
         /* Request a reload of /proc/swaps, so that following units
          * can follow our state change */
-        u->meta.manager->request_reload = true;
+        u->manager->request_reload = true;
 }
 
 static void swap_timer_event(Unit *u, uint64_t elapsed, Watch *w) {
@@ -998,38 +998,38 @@ static void swap_timer_event(Unit *u, uint64_t elapsed, Watch *w) {
         switch (s->state) {
 
         case SWAP_ACTIVATING:
-                log_warning("%s activation timed out. Stopping.", u->meta.id);
+                log_warning("%s activation timed out. Stopping.", u->id);
                 swap_enter_signal(s, SWAP_ACTIVATING_SIGTERM, false);
                 break;
 
         case SWAP_DEACTIVATING:
-                log_warning("%s deactivation timed out. Stopping.", u->meta.id);
+                log_warning("%s deactivation timed out. Stopping.", u->id);
                 swap_enter_signal(s, SWAP_DEACTIVATING_SIGTERM, false);
                 break;
 
         case SWAP_ACTIVATING_SIGTERM:
                 if (s->exec_context.send_sigkill) {
-                        log_warning("%s activation timed out. Killing.", u->meta.id);
+                        log_warning("%s activation timed out. Killing.", u->id);
                         swap_enter_signal(s, SWAP_ACTIVATING_SIGKILL, false);
                 } else {
-                        log_warning("%s activation timed out. Skipping SIGKILL. Ignoring.", u->meta.id);
+                        log_warning("%s activation timed out. Skipping SIGKILL. Ignoring.", u->id);
                         swap_enter_dead(s, false);
                 }
                 break;
 
         case SWAP_DEACTIVATING_SIGTERM:
                 if (s->exec_context.send_sigkill) {
-                        log_warning("%s deactivation timed out. Killing.", u->meta.id);
+                        log_warning("%s deactivation timed out. Killing.", u->id);
                         swap_enter_signal(s, SWAP_DEACTIVATING_SIGKILL, false);
                 } else {
-                        log_warning("%s deactivation timed out. Skipping SIGKILL. Ignoring.", u->meta.id);
+                        log_warning("%s deactivation timed out. Skipping SIGKILL. Ignoring.", u->id);
                         swap_enter_dead(s, false);
                 }
                 break;
 
         case SWAP_ACTIVATING_SIGKILL:
         case SWAP_DEACTIVATING_SIGKILL:
-                log_warning("%s swap process still around after SIGKILL. Ignoring.", u->meta.id);
+                log_warning("%s swap process still around after SIGKILL. Ignoring.", u->id);
                 swap_enter_dead(s, false);
                 break;
 
@@ -1096,7 +1096,7 @@ int swap_dispatch_reload(Manager *m) {
 }
 
 int swap_fd_event(Manager *m, int events) {
-        Meta *meta;
+        Unit *meta;
         int r;
 
         assert(m);
diff --git a/src/swap.h b/src/swap.h
index 0d5c9a2..ea98bc2 100644
--- a/src/swap.h
+++ b/src/swap.h
@@ -57,7 +57,7 @@ typedef struct SwapParameters {
 } SwapParameters;
 
 struct Swap {
-        Meta meta;
+        Unit meta;
 
         char *what;
 
diff --git a/src/target.c b/src/target.c
index b774cfb..fb67ff3 100644
--- a/src/target.c
+++ b/src/target.c
@@ -93,8 +93,8 @@ static int target_load(Unit *u) {
                 return r;
 
         /* This is a new unit? Then let's add in some extras */
-        if (u->meta.load_state == UNIT_LOADED) {
-                if (u->meta.default_dependencies)
+        if (u->load_state == UNIT_LOADED) {
+                if (u->default_dependencies)
                         if ((r = target_add_default_dependencies(t)) < 0)
                                 return r;
         }
diff --git a/src/target.h b/src/target.h
index b1d055f..5b97c86 100644
--- a/src/target.h
+++ b/src/target.h
@@ -34,7 +34,7 @@ typedef enum TargetState {
 } TargetState;
 
 struct Target {
-        Meta meta;
+        Unit meta;
 
         TargetState state, deserialized_state;
 };
diff --git a/src/timer.c b/src/timer.c
index 87adb29..6056d31 100644
--- a/src/timer.c
+++ b/src/timer.c
@@ -40,7 +40,7 @@ static void timer_init(Unit *u) {
         Timer *t = TIMER(u);
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         t->next_elapse = (usec_t) -1;
 }
@@ -96,12 +96,12 @@ static int timer_load(Unit *u) {
         int r;
 
         assert(u);
-        assert(u->meta.load_state == UNIT_STUB);
+        assert(u->load_state == UNIT_STUB);
 
         if ((r = unit_load_fragment_and_dropin(u)) < 0)
                 return r;
 
-        if (u->meta.load_state == UNIT_LOADED) {
+        if (u->load_state == UNIT_LOADED) {
 
                 if (!UNIT_DEREF(t->unit)) {
                         Unit *x;
@@ -135,7 +135,7 @@ static void timer_dump(Unit *u, FILE *f, const char *prefix) {
                 "%sTimer State: %s\n"
                 "%sUnit: %s\n",
                 prefix, timer_state_to_string(t->state),
-                prefix, UNIT_DEREF(t->unit)->meta.id);
+                prefix, UNIT_DEREF(t->unit)->id);
 
         LIST_FOREACH(value, v, t->values)
                 fprintf(f,
@@ -225,18 +225,18 @@ static void timer_enter_waiting(Timer *t, bool initial) {
 
                 case TIMER_UNIT_ACTIVE:
 
-                        if (UNIT_DEREF(t->unit)->meta.inactive_exit_timestamp.monotonic <= 0)
+                        if (UNIT_DEREF(t->unit)->inactive_exit_timestamp.monotonic <= 0)
                                 continue;
 
-                        base = UNIT_DEREF(t->unit)->meta.inactive_exit_timestamp.monotonic;
+                        base = UNIT_DEREF(t->unit)->inactive_exit_timestamp.monotonic;
                         break;
 
                 case TIMER_UNIT_INACTIVE:
 
-                        if (UNIT_DEREF(t->unit)->meta.inactive_enter_timestamp.monotonic <= 0)
+                        if (UNIT_DEREF(t->unit)->inactive_enter_timestamp.monotonic <= 0)
                                 continue;
 
-                        base = UNIT_DEREF(t->unit)->meta.inactive_enter_timestamp.monotonic;
+                        base = UNIT_DEREF(t->unit)->inactive_enter_timestamp.monotonic;
                         break;
 
                 default:
@@ -306,7 +306,7 @@ static int timer_start(Unit *u) {
         assert(t);
         assert(t->state == TIMER_DEAD || t->state == TIMER_FAILED);
 
-        if (UNIT_DEREF(t->unit)->meta.load_state != UNIT_LOADED)
+        if (UNIT_DEREF(t->unit)->load_state != UNIT_LOADED)
                 return -ENOENT;
 
         t->failure = false;
@@ -378,7 +378,7 @@ static void timer_timer_event(Unit *u, uint64_t elapsed, Watch *w) {
         if (t->state != TIMER_WAITING)
                 return;
 
-        log_debug("Timer elapsed on %s", u->meta.id);
+        log_debug("Timer elapsed on %s", u->id);
         timer_enter_running(t);
 }
 
@@ -386,17 +386,17 @@ void timer_unit_notify(Unit *u, UnitActiveState new_state) {
         Iterator i;
         Unit *k;
 
-        if (u->meta.type == UNIT_TIMER)
+        if (u->type == UNIT_TIMER)
                 return;
 
-        SET_FOREACH(k, u->meta.dependencies[UNIT_TRIGGERED_BY], i) {
+        SET_FOREACH(k, u->dependencies[UNIT_TRIGGERED_BY], i) {
                 Timer *t;
                 TimerValue *v;
 
-                if (k->meta.type != UNIT_TIMER)
+                if (k->type != UNIT_TIMER)
                         continue;
 
-                if (k->meta.load_state != UNIT_LOADED)
+                if (k->load_state != UNIT_LOADED)
                         continue;
 
                 t = TIMER(k);
diff --git a/src/timer.h b/src/timer.h
index ad55cf7..d5cbc11 100644
--- a/src/timer.h
+++ b/src/timer.h
@@ -57,7 +57,7 @@ typedef struct TimerValue {
 } TimerValue;
 
 struct Timer {
-        Meta meta;
+        Unit meta;
 
         LIST_HEAD(TimerValue, values);
         usec_t next_elapse;
diff --git a/src/unit.c b/src/unit.c
index c629e14..cc193ed 100644
--- a/src/unit.c
+++ b/src/unit.c
@@ -61,23 +61,23 @@ Unit *unit_new(Manager *m, size_t size) {
         Unit *u;
 
         assert(m);
-        assert(size >= sizeof(Meta));
+        assert(size >= sizeof(Unit));
 
         u = malloc0(size);
         if (!u)
                 return NULL;
 
-        u->meta.names = set_new(string_hash_func, string_compare_func);
-        if (!u->meta.names) {
+        u->names = set_new(string_hash_func, string_compare_func);
+        if (!u->names) {
                 free(u);
                 return NULL;
         }
 
-        u->meta.manager = m;
-        u->meta.type = _UNIT_TYPE_INVALID;
-        u->meta.deserialized_job = _JOB_TYPE_INVALID;
-        u->meta.default_dependencies = true;
-        u->meta.unit_file_state = _UNIT_FILE_STATE_INVALID;
+        u->manager = m;
+        u->type = _UNIT_TYPE_INVALID;
+        u->deserialized_job = _JOB_TYPE_INVALID;
+        u->default_dependencies = true;
+        u->unit_file_state = _UNIT_FILE_STATE_INVALID;
 
         return u;
 }
@@ -86,7 +86,7 @@ bool unit_has_name(Unit *u, const char *name) {
         assert(u);
         assert(name);
 
-        return !!set_get(u->meta.names, (char*) name);
+        return !!set_get(u->names, (char*) name);
 }
 
 int unit_add_name(Unit *u, const char *text) {
@@ -98,10 +98,10 @@ int unit_add_name(Unit *u, const char *text) {
         assert(text);
 
         if (unit_name_is_template(text)) {
-                if (!u->meta.instance)
+                if (!u->instance)
                         return -EINVAL;
 
-                s = unit_name_replace_instance(text, u->meta.instance);
+                s = unit_name_replace_instance(text, u->instance);
         } else
                 s = strdup(text);
 
@@ -115,7 +115,7 @@ int unit_add_name(Unit *u, const char *text) {
 
         assert_se((t = unit_name_to_type(s)) >= 0);
 
-        if (u->meta.type != _UNIT_TYPE_INVALID && t != u->meta.type) {
+        if (u->type != _UNIT_TYPE_INVALID && t != u->type) {
                 r = -EINVAL;
                 goto fail;
         }
@@ -130,41 +130,41 @@ int unit_add_name(Unit *u, const char *text) {
 
         /* Ensure that this unit is either instanced or not instanced,
          * but not both. */
-        if (u->meta.type != _UNIT_TYPE_INVALID && !u->meta.instance != !i) {
+        if (u->type != _UNIT_TYPE_INVALID && !u->instance != !i) {
                 r = -EINVAL;
                 goto fail;
         }
 
         if (unit_vtable[t]->no_alias &&
-            !set_isempty(u->meta.names) &&
-            !set_get(u->meta.names, s)) {
+            !set_isempty(u->names) &&
+            !set_get(u->names, s)) {
                 r = -EEXIST;
                 goto fail;
         }
 
-        if (hashmap_size(u->meta.manager->units) >= MANAGER_MAX_NAMES) {
+        if (hashmap_size(u->manager->units) >= MANAGER_MAX_NAMES) {
                 r = -E2BIG;
                 goto fail;
         }
 
-        if ((r = set_put(u->meta.names, s)) < 0) {
+        if ((r = set_put(u->names, s)) < 0) {
                 if (r == -EEXIST)
                         r = 0;
                 goto fail;
         }
 
-        if ((r = hashmap_put(u->meta.manager->units, s, u)) < 0) {
-                set_remove(u->meta.names, s);
+        if ((r = hashmap_put(u->manager->units, s, u)) < 0) {
+                set_remove(u->names, s);
                 goto fail;
         }
 
-        if (u->meta.type == _UNIT_TYPE_INVALID) {
+        if (u->type == _UNIT_TYPE_INVALID) {
 
-                u->meta.type = t;
-                u->meta.id = s;
-                u->meta.instance = i;
+                u->type = t;
+                u->id = s;
+                u->instance = i;
 
-                LIST_PREPEND(Meta, units_by_type, u->meta.manager->units_by_type[t], &u->meta);
+                LIST_PREPEND(Unit, units_by_type, u->manager->units_by_type[t], u);
 
                 if (UNIT_VTABLE(u)->init)
                         UNIT_VTABLE(u)->init(u);
@@ -190,17 +190,17 @@ int unit_choose_id(Unit *u, const char *name) {
 
         if (unit_name_is_template(name)) {
 
-                if (!u->meta.instance)
+                if (!u->instance)
                         return -EINVAL;
 
-                if (!(t = unit_name_replace_instance(name, u->meta.instance)))
+                if (!(t = unit_name_replace_instance(name, u->instance)))
                         return -ENOMEM;
 
                 name = t;
         }
 
         /* Selects one of the names of this unit as the id */
-        s = set_get(u->meta.names, (char*) name);
+        s = set_get(u->names, (char*) name);
         free(t);
 
         if (!s)
@@ -209,10 +209,10 @@ int unit_choose_id(Unit *u, const char *name) {
         if ((r = unit_name_to_instance(s, &i)) < 0)
                 return r;
 
-        u->meta.id = s;
+        u->id = s;
 
-        free(u->meta.instance);
-        u->meta.instance = i;
+        free(u->instance);
+        u->instance = i;
 
         unit_add_to_dbus_queue(u);
 
@@ -227,8 +227,8 @@ int unit_set_description(Unit *u, const char *description) {
         if (!(s = strdup(description)))
                 return -ENOMEM;
 
-        free(u->meta.description);
-        u->meta.description = s;
+        free(u->description);
+        u->description = s;
 
         unit_add_to_dbus_queue(u);
         return 0;
@@ -237,16 +237,16 @@ int unit_set_description(Unit *u, const char *description) {
 bool unit_check_gc(Unit *u) {
         assert(u);
 
-        if (u->meta.load_state == UNIT_STUB)
+        if (u->load_state == UNIT_STUB)
                 return true;
 
         if (UNIT_VTABLE(u)->no_gc)
                 return true;
 
-        if (u->meta.no_gc)
+        if (u->no_gc)
                 return true;
 
-        if (u->meta.job)
+        if (u->job)
                 return true;
 
         if (unit_active_state(u) != UNIT_INACTIVE)
@@ -261,58 +261,58 @@ bool unit_check_gc(Unit *u) {
 
 void unit_add_to_load_queue(Unit *u) {
         assert(u);
-        assert(u->meta.type != _UNIT_TYPE_INVALID);
+        assert(u->type != _UNIT_TYPE_INVALID);
 
-        if (u->meta.load_state != UNIT_STUB || u->meta.in_load_queue)
+        if (u->load_state != UNIT_STUB || u->in_load_queue)
                 return;
 
-        LIST_PREPEND(Meta, load_queue, u->meta.manager->load_queue, &u->meta);
-        u->meta.in_load_queue = true;
+        LIST_PREPEND(Unit, load_queue, u->manager->load_queue, u);
+        u->in_load_queue = true;
 }
 
 void unit_add_to_cleanup_queue(Unit *u) {
         assert(u);
 
-        if (u->meta.in_cleanup_queue)
+        if (u->in_cleanup_queue)
                 return;
 
-        LIST_PREPEND(Meta, cleanup_queue, u->meta.manager->cleanup_queue, &u->meta);
-        u->meta.in_cleanup_queue = true;
+        LIST_PREPEND(Unit, cleanup_queue, u->manager->cleanup_queue, u);
+        u->in_cleanup_queue = true;
 }
 
 void unit_add_to_gc_queue(Unit *u) {
         assert(u);
 
-        if (u->meta.in_gc_queue || u->meta.in_cleanup_queue)
+        if (u->in_gc_queue || u->in_cleanup_queue)
                 return;
 
         if (unit_check_gc(u))
                 return;
 
-        LIST_PREPEND(Meta, gc_queue, u->meta.manager->gc_queue, &u->meta);
-        u->meta.in_gc_queue = true;
+        LIST_PREPEND(Unit, gc_queue, u->manager->gc_queue, u);
+        u->in_gc_queue = true;
 
-        u->meta.manager->n_in_gc_queue ++;
+        u->manager->n_in_gc_queue ++;
 
-        if (u->meta.manager->gc_queue_timestamp <= 0)
-                u->meta.manager->gc_queue_timestamp = now(CLOCK_MONOTONIC);
+        if (u->manager->gc_queue_timestamp <= 0)
+                u->manager->gc_queue_timestamp = now(CLOCK_MONOTONIC);
 }
 
 void unit_add_to_dbus_queue(Unit *u) {
         assert(u);
-        assert(u->meta.type != _UNIT_TYPE_INVALID);
+        assert(u->type != _UNIT_TYPE_INVALID);
 
-        if (u->meta.load_state == UNIT_STUB || u->meta.in_dbus_queue)
+        if (u->load_state == UNIT_STUB || u->in_dbus_queue)
                 return;
 
         /* Shortcut things if nobody cares */
-        if (!bus_has_subscriber(u->meta.manager)) {
-                u->meta.sent_dbus_new_signal = true;
+        if (!bus_has_subscriber(u->manager)) {
+                u->sent_dbus_new_signal = true;
                 return;
         }
 
-        LIST_PREPEND(Meta, dbus_queue, u->meta.manager->dbus_unit_queue, &u->meta);
-        u->meta.in_dbus_queue = true;
+        LIST_PREPEND(Unit, dbus_queue, u->manager->dbus_unit_queue, u);
+        u->in_dbus_queue = true;
 }
 
 static void bidi_set_free(Unit *u, Set *s) {
@@ -328,7 +328,7 @@ static void bidi_set_free(Unit *u, Set *s) {
                 UnitDependency d;
 
                 for (d = 0; d < _UNIT_DEPENDENCY_MAX; d++)
-                        set_remove(other->meta.dependencies[d], u);
+                        set_remove(other->dependencies[d], u);
 
                 unit_add_to_gc_queue(other);
         }
@@ -345,49 +345,49 @@ void unit_free(Unit *u) {
 
         bus_unit_send_removed_signal(u);
 
-        if (u->meta.load_state != UNIT_STUB)
+        if (u->load_state != UNIT_STUB)
                 if (UNIT_VTABLE(u)->done)
                         UNIT_VTABLE(u)->done(u);
 
-        SET_FOREACH(t, u->meta.names, i)
-                hashmap_remove_value(u->meta.manager->units, t, u);
+        SET_FOREACH(t, u->names, i)
+                hashmap_remove_value(u->manager->units, t, u);
 
-        if (u->meta.job)
-                job_free(u->meta.job);
+        if (u->job)
+                job_free(u->job);
 
         for (d = 0; d < _UNIT_DEPENDENCY_MAX; d++)
-                bidi_set_free(u, u->meta.dependencies[d]);
+                bidi_set_free(u, u->dependencies[d]);
 
-        if (u->meta.type != _UNIT_TYPE_INVALID)
-                LIST_REMOVE(Meta, units_by_type, u->meta.manager->units_by_type[u->meta.type], &u->meta);
+        if (u->type != _UNIT_TYPE_INVALID)
+                LIST_REMOVE(Unit, units_by_type, u->manager->units_by_type[u->type], u);
 
-        if (u->meta.in_load_queue)
-                LIST_REMOVE(Meta, load_queue, u->meta.manager->load_queue, &u->meta);
+        if (u->in_load_queue)
+                LIST_REMOVE(Unit, load_queue, u->manager->load_queue, u);
 
-        if (u->meta.in_dbus_queue)
-                LIST_REMOVE(Meta, dbus_queue, u->meta.manager->dbus_unit_queue, &u->meta);
+        if (u->in_dbus_queue)
+                LIST_REMOVE(Unit, dbus_queue, u->manager->dbus_unit_queue, u);
 
-        if (u->meta.in_cleanup_queue)
-                LIST_REMOVE(Meta, cleanup_queue, u->meta.manager->cleanup_queue, &u->meta);
+        if (u->in_cleanup_queue)
+                LIST_REMOVE(Unit, cleanup_queue, u->manager->cleanup_queue, u);
 
-        if (u->meta.in_gc_queue) {
-                LIST_REMOVE(Meta, gc_queue, u->meta.manager->gc_queue, &u->meta);
-                u->meta.manager->n_in_gc_queue--;
+        if (u->in_gc_queue) {
+                LIST_REMOVE(Unit, gc_queue, u->manager->gc_queue, u);
+                u->manager->n_in_gc_queue--;
         }
 
-        cgroup_bonding_free_list(u->meta.cgroup_bondings, u->meta.manager->n_reloading <= 0);
-        cgroup_attribute_free_list(u->meta.cgroup_attributes);
+        cgroup_bonding_free_list(u->cgroup_bondings, u->manager->n_reloading <= 0);
+        cgroup_attribute_free_list(u->cgroup_attributes);
 
-        free(u->meta.description);
-        free(u->meta.fragment_path);
-        free(u->meta.instance);
+        free(u->description);
+        free(u->fragment_path);
+        free(u->instance);
 
-        set_free_free(u->meta.names);
+        set_free_free(u->names);
 
-        condition_free_list(u->meta.conditions);
+        condition_free_list(u->conditions);
 
-        while (u->meta.refs)
-                unit_ref_unset(u->meta.refs);
+        while (u->refs)
+                unit_ref_unset(u->refs);
 
         free(u);
 }
@@ -395,7 +395,7 @@ void unit_free(Unit *u) {
 UnitActiveState unit_active_state(Unit *u) {
         assert(u);
 
-        if (u->meta.load_state == UNIT_MERGED)
+        if (u->load_state == UNIT_MERGED)
                 return unit_active_state(unit_follow_merge(u));
 
         /* After a reload it might happen that a unit is not correctly
@@ -433,14 +433,14 @@ static void merge_names(Unit *u, Unit *other) {
         assert(u);
         assert(other);
 
-        complete_move(&u->meta.names, &other->meta.names);
+        complete_move(&u->names, &other->names);
 
-        set_free_free(other->meta.names);
-        other->meta.names = NULL;
-        other->meta.id = NULL;
+        set_free_free(other->names);
+        other->names = NULL;
+        other->id = NULL;
 
-        SET_FOREACH(t, u->meta.names, i)
-                assert_se(hashmap_replace(u->meta.manager->units, t, u) == 0);
+        SET_FOREACH(t, u->names, i)
+                assert_se(hashmap_replace(u->manager->units, t, u) == 0);
 }
 
 static void merge_dependencies(Unit *u, Unit *other, UnitDependency d) {
@@ -453,23 +453,23 @@ static void merge_dependencies(Unit *u, Unit *other, UnitDependency d) {
         assert(d < _UNIT_DEPENDENCY_MAX);
 
         /* Fix backwards pointers */
-        SET_FOREACH(back, other->meta.dependencies[d], i) {
+        SET_FOREACH(back, other->dependencies[d], i) {
                 UnitDependency k;
 
                 for (k = 0; k < _UNIT_DEPENDENCY_MAX; k++)
-                        if ((r = set_remove_and_put(back->meta.dependencies[k], other, u)) < 0) {
+                        if ((r = set_remove_and_put(back->dependencies[k], other, u)) < 0) {
 
                                 if (r == -EEXIST)
-                                        set_remove(back->meta.dependencies[k], other);
+                                        set_remove(back->dependencies[k], other);
                                 else
                                         assert(r == -ENOENT);
                         }
         }
 
-        complete_move(&u->meta.dependencies[d], &other->meta.dependencies[d]);
+        complete_move(&u->dependencies[d], &other->dependencies[d]);
 
-        set_free(other->meta.dependencies[d]);
-        other->meta.dependencies[d] = NULL;
+        set_free(other->dependencies[d]);
+        other->dependencies[d] = NULL;
 }
 
 int unit_merge(Unit *u, Unit *other) {
@@ -477,25 +477,25 @@ int unit_merge(Unit *u, Unit *other) {
 
         assert(u);
         assert(other);
-        assert(u->meta.manager == other->meta.manager);
-        assert(u->meta.type != _UNIT_TYPE_INVALID);
+        assert(u->manager == other->manager);
+        assert(u->type != _UNIT_TYPE_INVALID);
 
         other = unit_follow_merge(other);
 
         if (other == u)
                 return 0;
 
-        if (u->meta.type != other->meta.type)
+        if (u->type != other->type)
                 return -EINVAL;
 
-        if (!u->meta.instance != !other->meta.instance)
+        if (!u->instance != !other->instance)
                 return -EINVAL;
 
-        if (other->meta.load_state != UNIT_STUB &&
-            other->meta.load_state != UNIT_ERROR)
+        if (other->load_state != UNIT_STUB &&
+            other->load_state != UNIT_ERROR)
                 return -EEXIST;
 
-        if (other->meta.job)
+        if (other->job)
                 return -EEXIST;
 
         if (!UNIT_IS_INACTIVE_OR_FAILED(unit_active_state(other)))
@@ -505,19 +505,19 @@ int unit_merge(Unit *u, Unit *other) {
         merge_names(u, other);
 
         /* Redirect all references */
-        while (other->meta.refs)
-                unit_ref_set(other->meta.refs, u);
+        while (other->refs)
+                unit_ref_set(other->refs, u);
 
         /* Merge dependencies */
         for (d = 0; d < _UNIT_DEPENDENCY_MAX; d++)
                 merge_dependencies(u, other, d);
 
-        other->meta.load_state = UNIT_MERGED;
-        other->meta.merged_into = u;
+        other->load_state = UNIT_MERGED;
+        other->merged_into = u;
 
         /* If there is still some data attached to the other node, we
          * don't need it anymore, and can free it. */
-        if (other->meta.load_state != UNIT_STUB)
+        if (other->load_state != UNIT_STUB)
                 if (UNIT_VTABLE(other)->done)
                         UNIT_VTABLE(other)->done(other);
 
@@ -536,16 +536,16 @@ int unit_merge_by_name(Unit *u, const char *name) {
         assert(name);
 
         if (unit_name_is_template(name)) {
-                if (!u->meta.instance)
+                if (!u->instance)
                         return -EINVAL;
 
-                if (!(s = unit_name_replace_instance(name, u->meta.instance)))
+                if (!(s = unit_name_replace_instance(name, u->instance)))
                         return -ENOMEM;
 
                 name = s;
         }
 
-        if (!(other = manager_get_unit(u->meta.manager, name)))
+        if (!(other = manager_get_unit(u->manager, name)))
                 r = unit_add_name(u, name);
         else
                 r = unit_merge(u, other);
@@ -557,8 +557,8 @@ int unit_merge_by_name(Unit *u, const char *name) {
 Unit* unit_follow_merge(Unit *u) {
         assert(u);
 
-        while (u->meta.load_state == UNIT_MERGED)
-                assert_se(u = u->meta.merged_into);
+        while (u->load_state == UNIT_MERGED)
+                assert_se(u = u->merged_into);
 
         return u;
 }
@@ -582,7 +582,7 @@ int unit_add_exec_dependencies(Unit *u, ExecContext *c) {
         /* If syslog or kernel logging is requested, make sure our own
          * logging daemon is run first. */
 
-        if (u->meta.manager->running_as == MANAGER_SYSTEM)
+        if (u->manager->running_as == MANAGER_SYSTEM)
                 if ((r = unit_add_two_dependencies_by_name(u, UNIT_REQUIRES, UNIT_AFTER, SPECIAL_STDOUT_SYSLOG_BRIDGE_SOCKET, NULL, true)) < 0)
                         return r;
 
@@ -592,10 +592,10 @@ int unit_add_exec_dependencies(Unit *u, ExecContext *c) {
 const char *unit_description(Unit *u) {
         assert(u);
 
-        if (u->meta.description)
-                return u->meta.description;
+        if (u->description)
+                return u->description;
 
-        return strna(u->meta.id);
+        return strna(u->id);
 }
 
 void unit_dump(Unit *u, FILE *f, const char *prefix) {
@@ -613,7 +613,7 @@ void unit_dump(Unit *u, FILE *f, const char *prefix) {
         Unit *following;
 
         assert(u);
-        assert(u->meta.type >= 0);
+        assert(u->type >= 0);
 
         if (!prefix)
                 prefix = "";
@@ -632,47 +632,47 @@ void unit_dump(Unit *u, FILE *f, const char *prefix) {
                 "%s\tInactive Enter Timestamp: %s\n"
                 "%s\tGC Check Good: %s\n"
                 "%s\tNeed Daemon Reload: %s\n",
-                prefix, u->meta.id,
+                prefix, u->id,
                 prefix, unit_description(u),
-                prefix, strna(u->meta.instance),
-                prefix, unit_load_state_to_string(u->meta.load_state),
+                prefix, strna(u->instance),
+                prefix, unit_load_state_to_string(u->load_state),
                 prefix, unit_active_state_to_string(unit_active_state(u)),
-                prefix, strna(format_timestamp(timestamp1, sizeof(timestamp1), u->meta.inactive_exit_timestamp.realtime)),
-                prefix, strna(format_timestamp(timestamp2, sizeof(timestamp2), u->meta.active_enter_timestamp.realtime)),
-                prefix, strna(format_timestamp(timestamp3, sizeof(timestamp3), u->meta.active_exit_timestamp.realtime)),
-                prefix, strna(format_timestamp(timestamp4, sizeof(timestamp4), u->meta.inactive_enter_timestamp.realtime)),
+                prefix, strna(format_timestamp(timestamp1, sizeof(timestamp1), u->inactive_exit_timestamp.realtime)),
+                prefix, strna(format_timestamp(timestamp2, sizeof(timestamp2), u->active_enter_timestamp.realtime)),
+                prefix, strna(format_timestamp(timestamp3, sizeof(timestamp3), u->active_exit_timestamp.realtime)),
+                prefix, strna(format_timestamp(timestamp4, sizeof(timestamp4), u->inactive_enter_timestamp.realtime)),
                 prefix, yes_no(unit_check_gc(u)),
                 prefix, yes_no(unit_need_daemon_reload(u)));
 
-        SET_FOREACH(t, u->meta.names, i)
+        SET_FOREACH(t, u->names, i)
                 fprintf(f, "%s\tName: %s\n", prefix, t);
 
         if ((following = unit_following(u)))
-                fprintf(f, "%s\tFollowing: %s\n", prefix, following->meta.id);
+                fprintf(f, "%s\tFollowing: %s\n", prefix, following->id);
 
-        if (u->meta.fragment_path)
-                fprintf(f, "%s\tFragment Path: %s\n", prefix, u->meta.fragment_path);
+        if (u->fragment_path)
+                fprintf(f, "%s\tFragment Path: %s\n", prefix, u->fragment_path);
 
-        if (u->meta.job_timeout > 0)
-                fprintf(f, "%s\tJob Timeout: %s\n", prefix, format_timespan(timespan, sizeof(timespan), u->meta.job_timeout));
+        if (u->job_timeout > 0)
+                fprintf(f, "%s\tJob Timeout: %s\n", prefix, format_timespan(timespan, sizeof(timespan), u->job_timeout));
 
-        condition_dump_list(u->meta.conditions, f, prefix);
+        condition_dump_list(u->conditions, f, prefix);
 
-        if (dual_timestamp_is_set(&u->meta.condition_timestamp))
+        if (dual_timestamp_is_set(&u->condition_timestamp))
                 fprintf(f,
                         "%s\tCondition Timestamp: %s\n"
                         "%s\tCondition Result: %s\n",
-                        prefix, strna(format_timestamp(timestamp1, sizeof(timestamp1), u->meta.condition_timestamp.realtime)),
-                        prefix, yes_no(u->meta.condition_result));
+                        prefix, strna(format_timestamp(timestamp1, sizeof(timestamp1), u->condition_timestamp.realtime)),
+                        prefix, yes_no(u->condition_result));
 
         for (d = 0; d < _UNIT_DEPENDENCY_MAX; d++) {
                 Unit *other;
 
-                SET_FOREACH(other, u->meta.dependencies[d], i)
-                        fprintf(f, "%s\t%s: %s\n", prefix, unit_dependency_to_string(d), other->meta.id);
+                SET_FOREACH(other, u->dependencies[d], i)
+                        fprintf(f, "%s\t%s: %s\n", prefix, unit_dependency_to_string(d), other->id);
         }
 
-        if (u->meta.load_state == UNIT_LOADED) {
+        if (u->load_state == UNIT_LOADED) {
                 CGroupBonding *b;
                 CGroupAttribute *a;
 
@@ -684,19 +684,19 @@ void unit_dump(Unit *u, FILE *f, const char *prefix) {
                         "%s\tOnFailureIsolate: %s\n"
                         "%s\tIgnoreOnIsolate: %s\n"
                         "%s\tIgnoreOnSnapshot: %s\n",
-                        prefix, yes_no(u->meta.stop_when_unneeded),
-                        prefix, yes_no(u->meta.refuse_manual_start),
-                        prefix, yes_no(u->meta.refuse_manual_stop),
-                        prefix, yes_no(u->meta.default_dependencies),
-                        prefix, yes_no(u->meta.on_failure_isolate),
-                        prefix, yes_no(u->meta.ignore_on_isolate),
-                        prefix, yes_no(u->meta.ignore_on_snapshot));
-
-                LIST_FOREACH(by_unit, b, u->meta.cgroup_bondings)
+                        prefix, yes_no(u->stop_when_unneeded),
+                        prefix, yes_no(u->refuse_manual_start),
+                        prefix, yes_no(u->refuse_manual_stop),
+                        prefix, yes_no(u->default_dependencies),
+                        prefix, yes_no(u->on_failure_isolate),
+                        prefix, yes_no(u->ignore_on_isolate),
+                        prefix, yes_no(u->ignore_on_snapshot));
+
+                LIST_FOREACH(by_unit, b, u->cgroup_bondings)
                         fprintf(f, "%s\tControlGroup: %s:%s\n",
                                 prefix, b->controller, b->path);
 
-                LIST_FOREACH(by_unit, a, u->meta.cgroup_attributes) {
+                LIST_FOREACH(by_unit, a, u->cgroup_attributes) {
                         char *v = NULL;
 
                         if (a->map_callback)
@@ -711,16 +711,16 @@ void unit_dump(Unit *u, FILE *f, const char *prefix) {
                 if (UNIT_VTABLE(u)->dump)
                         UNIT_VTABLE(u)->dump(u, f, prefix2);
 
-        } else if (u->meta.load_state == UNIT_MERGED)
+        } else if (u->load_state == UNIT_MERGED)
                 fprintf(f,
                         "%s\tMerged into: %s\n",
-                        prefix, u->meta.merged_into->meta.id);
-        else if (u->meta.load_state == UNIT_ERROR)
-                fprintf(f, "%s\tLoad Error Code: %s\n", prefix, strerror(-u->meta.load_error));
+                        prefix, u->merged_into->id);
+        else if (u->load_state == UNIT_ERROR)
+                fprintf(f, "%s\tLoad Error Code: %s\n", prefix, strerror(-u->load_error));
 
 
-        if (u->meta.job)
-                job_dump(u->meta.job, f, prefix2);
+        if (u->job)
+                job_dump(u->job, f, prefix2);
 
         free(p2);
 }
@@ -735,7 +735,7 @@ int unit_load_fragment_and_dropin(Unit *u) {
         if ((r = unit_load_fragment(u)) < 0)
                 return r;
 
-        if (u->meta.load_state == UNIT_STUB)
+        if (u->load_state == UNIT_STUB)
                 return -ENOENT;
 
         /* Load drop-in directory data */
@@ -758,8 +758,8 @@ int unit_load_fragment_and_dropin_optional(Unit *u) {
         if ((r = unit_load_fragment(u)) < 0)
                 return r;
 
-        if (u->meta.load_state == UNIT_STUB)
-                u->meta.load_state = UNIT_LOADED;
+        if (u->load_state == UNIT_STUB)
+                u->load_state = UNIT_LOADED;
 
         /* Load drop-in directory data */
         if ((r = unit_load_dropin(unit_follow_merge(u))) < 0)
@@ -772,23 +772,23 @@ int unit_add_default_target_dependency(Unit *u, Unit *target) {
         assert(u);
         assert(target);
 
-        if (target->meta.type != UNIT_TARGET)
+        if (target->type != UNIT_TARGET)
                 return 0;
 
         /* Only add the dependency if both units are loaded, so that
          * that loop check below is reliable */
-        if (u->meta.load_state != UNIT_LOADED ||
-            target->meta.load_state != UNIT_LOADED)
+        if (u->load_state != UNIT_LOADED ||
+            target->load_state != UNIT_LOADED)
                 return 0;
 
         /* If either side wants no automatic dependencies, then let's
          * skip this */
-        if (!u->meta.default_dependencies ||
-            !target->meta.default_dependencies)
+        if (!u->default_dependencies ||
+            !target->default_dependencies)
                 return 0;
 
         /* Don't create loops */
-        if (set_get(target->meta.dependencies[UNIT_BEFORE], u))
+        if (set_get(target->dependencies[UNIT_BEFORE], u))
                 return 0;
 
         return unit_add_dependency(target, UNIT_AFTER, u, true);
@@ -810,7 +810,7 @@ static int unit_add_default_dependencies(Unit *u) {
         assert(u);
 
         for (k = 0; k < ELEMENTSOF(deps); k++)
-                SET_FOREACH(target, u->meta.dependencies[deps[k]], i)
+                SET_FOREACH(target, u->dependencies[deps[k]], i)
                         if ((r = unit_add_default_target_dependency(u, target)) < 0)
                                 return r;
 
@@ -822,42 +822,42 @@ int unit_load(Unit *u) {
 
         assert(u);
 
-        if (u->meta.in_load_queue) {
-                LIST_REMOVE(Meta, load_queue, u->meta.manager->load_queue, &u->meta);
-                u->meta.in_load_queue = false;
+        if (u->in_load_queue) {
+                LIST_REMOVE(Unit, load_queue, u->manager->load_queue, u);
+                u->in_load_queue = false;
         }
 
-        if (u->meta.type == _UNIT_TYPE_INVALID)
+        if (u->type == _UNIT_TYPE_INVALID)
                 return -EINVAL;
 
-        if (u->meta.load_state != UNIT_STUB)
+        if (u->load_state != UNIT_STUB)
                 return 0;
 
         if (UNIT_VTABLE(u)->load)
                 if ((r = UNIT_VTABLE(u)->load(u)) < 0)
                         goto fail;
 
-        if (u->meta.load_state == UNIT_STUB) {
+        if (u->load_state == UNIT_STUB) {
                 r = -ENOENT;
                 goto fail;
         }
 
-        if (u->meta.load_state == UNIT_LOADED &&
-            u->meta.default_dependencies)
+        if (u->load_state == UNIT_LOADED &&
+            u->default_dependencies)
                 if ((r = unit_add_default_dependencies(u)) < 0)
                         goto fail;
 
-        if (u->meta.on_failure_isolate &&
-            set_size(u->meta.dependencies[UNIT_ON_FAILURE]) > 1) {
+        if (u->on_failure_isolate &&
+            set_size(u->dependencies[UNIT_ON_FAILURE]) > 1) {
 
                 log_error("More than one OnFailure= dependencies specified for %s but OnFailureIsolate= enabled. Refusing.",
-                          u->meta.id);
+                          u->id);
 
                 r = -EINVAL;
                 goto fail;
         }
 
-        assert((u->meta.load_state != UNIT_MERGED) == !u->meta.merged_into);
+        assert((u->load_state != UNIT_MERGED) == !u->merged_into);
 
         unit_add_to_dbus_queue(unit_follow_merge(u));
         unit_add_to_gc_queue(u);
@@ -865,12 +865,12 @@ int unit_load(Unit *u) {
         return 0;
 
 fail:
-        u->meta.load_state = UNIT_ERROR;
-        u->meta.load_error = r;
+        u->load_state = UNIT_ERROR;
+        u->load_error = r;
         unit_add_to_dbus_queue(u);
         unit_add_to_gc_queue(u);
 
-        log_debug("Failed to load configuration for %s: %s", u->meta.id, strerror(-r));
+        log_debug("Failed to load configuration for %s: %s", u->id, strerror(-r));
 
         return r;
 }
@@ -878,10 +878,10 @@ fail:
 bool unit_condition_test(Unit *u) {
         assert(u);
 
-        dual_timestamp_get(&u->meta.condition_timestamp);
-        u->meta.condition_result = condition_test_list(u->meta.conditions);
+        dual_timestamp_get(&u->condition_timestamp);
+        u->condition_result = condition_test_list(u->conditions);
 
-        return u->meta.condition_result;
+        return u->condition_result;
 }
 
 /* Errors:
@@ -896,7 +896,7 @@ int unit_start(Unit *u) {
 
         assert(u);
 
-        if (u->meta.load_state != UNIT_LOADED)
+        if (u->load_state != UNIT_LOADED)
                 return -EINVAL;
 
         /* If this is already started, then this will succeed. Note
@@ -913,13 +913,13 @@ int unit_start(Unit *u) {
          * but we don't want to recheck the condition in that case. */
         if (state != UNIT_ACTIVATING &&
             !unit_condition_test(u)) {
-                log_debug("Starting of %s requested but condition failed. Ignoring.", u->meta.id);
+                log_debug("Starting of %s requested but condition failed. Ignoring.", u->id);
                 return -EALREADY;
         }
 
         /* Forward to the main object, if we aren't it. */
         if ((following = unit_following(u))) {
-                log_debug("Redirecting start request from %s to %s.", u->meta.id, following->meta.id);
+                log_debug("Redirecting start request from %s to %s.", u->id, following->id);
                 return unit_start(following);
         }
 
@@ -949,7 +949,7 @@ bool unit_can_isolate(Unit *u) {
         assert(u);
 
         return unit_can_start(u) &&
-                u->meta.allow_isolate;
+                u->allow_isolate;
 }
 
 /* Errors:
@@ -968,7 +968,7 @@ int unit_stop(Unit *u) {
                 return -EALREADY;
 
         if ((following = unit_following(u))) {
-                log_debug("Redirecting stop request from %s to %s.", u->meta.id, following->meta.id);
+                log_debug("Redirecting stop request from %s to %s.", u->id, following->id);
                 return unit_stop(following);
         }
 
@@ -992,7 +992,7 @@ int unit_reload(Unit *u) {
 
         assert(u);
 
-        if (u->meta.load_state != UNIT_LOADED)
+        if (u->load_state != UNIT_LOADED)
                 return -EINVAL;
 
         if (!unit_can_reload(u))
@@ -1006,7 +1006,7 @@ int unit_reload(Unit *u) {
                 return -ENOEXEC;
 
         if ((following = unit_following(u))) {
-                log_debug("Redirecting reload request from %s to %s.", u->meta.id, following->meta.id);
+                log_debug("Redirecting reload request from %s to %s.", u->id, following->id);
                 return unit_reload(following);
         }
 
@@ -1035,32 +1035,32 @@ static void unit_check_unneeded(Unit *u) {
         /* If this service shall be shut down when unneeded then do
          * so. */
 
-        if (!u->meta.stop_when_unneeded)
+        if (!u->stop_when_unneeded)
                 return;
 
         if (!UNIT_IS_ACTIVE_OR_ACTIVATING(unit_active_state(u)))
                 return;
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_REQUIRED_BY], i)
+        SET_FOREACH(other, u->dependencies[UNIT_REQUIRED_BY], i)
                 if (unit_pending_active(other))
                         return;
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_REQUIRED_BY_OVERRIDABLE], i)
+        SET_FOREACH(other, u->dependencies[UNIT_REQUIRED_BY_OVERRIDABLE], i)
                 if (unit_pending_active(other))
                         return;
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_WANTED_BY], i)
+        SET_FOREACH(other, u->dependencies[UNIT_WANTED_BY], i)
                 if (unit_pending_active(other))
                         return;
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_BOUND_BY], i)
+        SET_FOREACH(other, u->dependencies[UNIT_BOUND_BY], i)
                 if (unit_pending_active(other))
                         return;
 
-        log_info("Service %s is not needed anymore. Stopping.", u->meta.id);
+        log_info("Service %s is not needed anymore. Stopping.", u->id);
 
         /* Ok, nobody needs us anymore. Sniff. Then let's commit suicide */
-        manager_add_job(u->meta.manager, JOB_STOP, u, JOB_FAIL, true, NULL, NULL);
+        manager_add_job(u->manager, JOB_STOP, u, JOB_FAIL, true, NULL, NULL);
 }
 
 static void retroactively_start_dependencies(Unit *u) {
@@ -1070,38 +1070,38 @@ static void retroactively_start_dependencies(Unit *u) {
         assert(u);
         assert(UNIT_IS_ACTIVE_OR_ACTIVATING(unit_active_state(u)));
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_REQUIRES], i)
-                if (!set_get(u->meta.dependencies[UNIT_AFTER], other) &&
+        SET_FOREACH(other, u->dependencies[UNIT_REQUIRES], i)
+                if (!set_get(u->dependencies[UNIT_AFTER], other) &&
                     !UNIT_IS_ACTIVE_OR_ACTIVATING(unit_active_state(other)))
-                        manager_add_job(u->meta.manager, JOB_START, other, JOB_REPLACE, true, NULL, NULL);
+                        manager_add_job(u->manager, JOB_START, other, JOB_REPLACE, true, NULL, NULL);
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_BIND_TO], i)
-                if (!set_get(u->meta.dependencies[UNIT_AFTER], other) &&
+        SET_FOREACH(other, u->dependencies[UNIT_BIND_TO], i)
+                if (!set_get(u->dependencies[UNIT_AFTER], other) &&
                     !UNIT_IS_ACTIVE_OR_ACTIVATING(unit_active_state(other)))
-                        manager_add_job(u->meta.manager, JOB_START, other, JOB_REPLACE, true, NULL, NULL);
+                        manager_add_job(u->manager, JOB_START, other, JOB_REPLACE, true, NULL, NULL);
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_REQUIRES_OVERRIDABLE], i)
-                if (!set_get(u->meta.dependencies[UNIT_AFTER], other) &&
+        SET_FOREACH(other, u->dependencies[UNIT_REQUIRES_OVERRIDABLE], i)
+                if (!set_get(u->dependencies[UNIT_AFTER], other) &&
                     !UNIT_IS_ACTIVE_OR_ACTIVATING(unit_active_state(other)))
-                        manager_add_job(u->meta.manager, JOB_START, other, JOB_FAIL, false, NULL, NULL);
+                        manager_add_job(u->manager, JOB_START, other, JOB_FAIL, false, NULL, NULL);
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_REQUISITE], i)
-                if (!set_get(u->meta.dependencies[UNIT_AFTER], other) &&
+        SET_FOREACH(other, u->dependencies[UNIT_REQUISITE], i)
+                if (!set_get(u->dependencies[UNIT_AFTER], other) &&
                     !UNIT_IS_ACTIVE_OR_ACTIVATING(unit_active_state(other)))
-                        manager_add_job(u->meta.manager, JOB_START, other, JOB_REPLACE, true, NULL, NULL);
+                        manager_add_job(u->manager, JOB_START, other, JOB_REPLACE, true, NULL, NULL);
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_WANTS], i)
-                if (!set_get(u->meta.dependencies[UNIT_AFTER], other) &&
+        SET_FOREACH(other, u->dependencies[UNIT_WANTS], i)
+                if (!set_get(u->dependencies[UNIT_AFTER], other) &&
                     !UNIT_IS_ACTIVE_OR_ACTIVATING(unit_active_state(other)))
-                        manager_add_job(u->meta.manager, JOB_START, other, JOB_FAIL, false, NULL, NULL);
+                        manager_add_job(u->manager, JOB_START, other, JOB_FAIL, false, NULL, NULL);
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_CONFLICTS], i)
+        SET_FOREACH(other, u->dependencies[UNIT_CONFLICTS], i)
                 if (!UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(other)))
-                        manager_add_job(u->meta.manager, JOB_STOP, other, JOB_REPLACE, true, NULL, NULL);
+                        manager_add_job(u->manager, JOB_STOP, other, JOB_REPLACE, true, NULL, NULL);
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_CONFLICTED_BY], i)
+        SET_FOREACH(other, u->dependencies[UNIT_CONFLICTED_BY], i)
                 if (!UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(other)))
-                        manager_add_job(u->meta.manager, JOB_STOP, other, JOB_REPLACE, true, NULL, NULL);
+                        manager_add_job(u->manager, JOB_STOP, other, JOB_REPLACE, true, NULL, NULL);
 }
 
 static void retroactively_stop_dependencies(Unit *u) {
@@ -1112,9 +1112,9 @@ static void retroactively_stop_dependencies(Unit *u) {
         assert(UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(u)));
 
         /* Pull down units which are bound to us recursively if enabled */
-        SET_FOREACH(other, u->meta.dependencies[UNIT_BOUND_BY], i)
+        SET_FOREACH(other, u->dependencies[UNIT_BOUND_BY], i)
                 if (!UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(other)))
-                        manager_add_job(u->meta.manager, JOB_STOP, other, JOB_REPLACE, true, NULL, NULL);
+                        manager_add_job(u->manager, JOB_STOP, other, JOB_REPLACE, true, NULL, NULL);
 }
 
 static void check_unneeded_dependencies(Unit *u) {
@@ -1125,22 +1125,22 @@ static void check_unneeded_dependencies(Unit *u) {
         assert(UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(u)));
 
         /* Garbage collect services that might not be needed anymore, if enabled */
-        SET_FOREACH(other, u->meta.dependencies[UNIT_REQUIRES], i)
+        SET_FOREACH(other, u->dependencies[UNIT_REQUIRES], i)
                 if (!UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(other)))
                         unit_check_unneeded(other);
-        SET_FOREACH(other, u->meta.dependencies[UNIT_REQUIRES_OVERRIDABLE], i)
+        SET_FOREACH(other, u->dependencies[UNIT_REQUIRES_OVERRIDABLE], i)
                 if (!UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(other)))
                         unit_check_unneeded(other);
-        SET_FOREACH(other, u->meta.dependencies[UNIT_WANTS], i)
+        SET_FOREACH(other, u->dependencies[UNIT_WANTS], i)
                 if (!UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(other)))
                         unit_check_unneeded(other);
-        SET_FOREACH(other, u->meta.dependencies[UNIT_REQUISITE], i)
+        SET_FOREACH(other, u->dependencies[UNIT_REQUISITE], i)
                 if (!UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(other)))
                         unit_check_unneeded(other);
-        SET_FOREACH(other, u->meta.dependencies[UNIT_REQUISITE_OVERRIDABLE], i)
+        SET_FOREACH(other, u->dependencies[UNIT_REQUISITE_OVERRIDABLE], i)
                 if (!UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(other)))
                         unit_check_unneeded(other);
-        SET_FOREACH(other, u->meta.dependencies[UNIT_BIND_TO], i)
+        SET_FOREACH(other, u->dependencies[UNIT_BIND_TO], i)
                 if (!UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(other)))
                         unit_check_unneeded(other);
 }
@@ -1151,15 +1151,15 @@ void unit_trigger_on_failure(Unit *u) {
 
         assert(u);
 
-        if (set_size(u->meta.dependencies[UNIT_ON_FAILURE]) <= 0)
+        if (set_size(u->dependencies[UNIT_ON_FAILURE]) <= 0)
                 return;
 
-        log_info("Triggering OnFailure= dependencies of %s.", u->meta.id);
+        log_info("Triggering OnFailure= dependencies of %s.", u->id);
 
-        SET_FOREACH(other, u->meta.dependencies[UNIT_ON_FAILURE], i) {
+        SET_FOREACH(other, u->dependencies[UNIT_ON_FAILURE], i) {
                 int r;
 
-                if ((r = manager_add_job(u->meta.manager, JOB_START, other, u->meta.on_failure_isolate ? JOB_ISOLATE : JOB_REPLACE, true, NULL, NULL)) < 0)
+                if ((r = manager_add_job(u->manager, JOB_START, other, u->on_failure_isolate ? JOB_ISOLATE : JOB_REPLACE, true, NULL, NULL)) < 0)
                         log_error("Failed to enqueue OnFailure= job: %s", strerror(-r));
         }
 }
@@ -1177,54 +1177,54 @@ void unit_notify(Unit *u, UnitActiveState os, UnitActiveState ns, bool reload_su
          * behaviour here. For example: if a mount point is remounted
          * this function will be called too! */
 
-        if (u->meta.manager->n_reloading <= 0) {
+        if (u->manager->n_reloading <= 0) {
                 dual_timestamp ts;
 
                 dual_timestamp_get(&ts);
 
                 if (UNIT_IS_INACTIVE_OR_FAILED(os) && !UNIT_IS_INACTIVE_OR_FAILED(ns))
-                        u->meta.inactive_exit_timestamp = ts;
+                        u->inactive_exit_timestamp = ts;
                 else if (!UNIT_IS_INACTIVE_OR_FAILED(os) && UNIT_IS_INACTIVE_OR_FAILED(ns))
-                        u->meta.inactive_enter_timestamp = ts;
+                        u->inactive_enter_timestamp = ts;
 
                 if (!UNIT_IS_ACTIVE_OR_RELOADING(os) && UNIT_IS_ACTIVE_OR_RELOADING(ns))
-                        u->meta.active_enter_timestamp = ts;
+                        u->active_enter_timestamp = ts;
                 else if (UNIT_IS_ACTIVE_OR_RELOADING(os) && !UNIT_IS_ACTIVE_OR_RELOADING(ns))
-                        u->meta.active_exit_timestamp = ts;
+                        u->active_exit_timestamp = ts;
 
                 timer_unit_notify(u, ns);
                 path_unit_notify(u, ns);
         }
 
         if (UNIT_IS_INACTIVE_OR_FAILED(ns))
-                cgroup_bonding_trim_list(u->meta.cgroup_bondings, true);
+                cgroup_bonding_trim_list(u->cgroup_bondings, true);
 
-        if (u->meta.job) {
+        if (u->job) {
                 unexpected = false;
 
-                if (u->meta.job->state == JOB_WAITING)
+                if (u->job->state == JOB_WAITING)
 
                         /* So we reached a different state for this
                          * job. Let's see if we can run it now if it
                          * failed previously due to EAGAIN. */
-                        job_add_to_run_queue(u->meta.job);
+                        job_add_to_run_queue(u->job);
 
                 /* Let's check whether this state change constitutes a
                  * finished job, or maybe contradicts a running job and
                  * hence needs to invalidate jobs. */
 
-                switch (u->meta.job->type) {
+                switch (u->job->type) {
 
                 case JOB_START:
                 case JOB_VERIFY_ACTIVE:
 
                         if (UNIT_IS_ACTIVE_OR_RELOADING(ns))
-                                job_finish_and_invalidate(u->meta.job, JOB_DONE);
-                        else if (u->meta.job->state == JOB_RUNNING && ns != UNIT_ACTIVATING) {
+                                job_finish_and_invalidate(u->job, JOB_DONE);
+                        else if (u->job->state == JOB_RUNNING && ns != UNIT_ACTIVATING) {
                                 unexpected = true;
 
                                 if (UNIT_IS_INACTIVE_OR_FAILED(ns))
-                                        job_finish_and_invalidate(u->meta.job, ns == UNIT_FAILED ? JOB_FAILED : JOB_DONE);
+                                        job_finish_and_invalidate(u->job, ns == UNIT_FAILED ? JOB_FAILED : JOB_DONE);
                         }
 
                         break;
@@ -1232,14 +1232,14 @@ void unit_notify(Unit *u, UnitActiveState os, UnitActiveState ns, bool reload_su
                 case JOB_RELOAD:
                 case JOB_RELOAD_OR_START:
 
-                        if (u->meta.job->state == JOB_RUNNING) {
+                        if (u->job->state == JOB_RUNNING) {
                                 if (ns == UNIT_ACTIVE)
-                                        job_finish_and_invalidate(u->meta.job, reload_success ? JOB_DONE : JOB_FAILED);
+                                        job_finish_and_invalidate(u->job, reload_success ? JOB_DONE : JOB_FAILED);
                                 else if (ns != UNIT_ACTIVATING && ns != UNIT_RELOADING) {
                                         unexpected = true;
 
                                         if (UNIT_IS_INACTIVE_OR_FAILED(ns))
-                                                job_finish_and_invalidate(u->meta.job, ns == UNIT_FAILED ? JOB_FAILED : JOB_DONE);
+                                                job_finish_and_invalidate(u->job, ns == UNIT_FAILED ? JOB_FAILED : JOB_DONE);
                                 }
                         }
 
@@ -1250,10 +1250,10 @@ void unit_notify(Unit *u, UnitActiveState os, UnitActiveState ns, bool reload_su
                 case JOB_TRY_RESTART:
 
                         if (UNIT_IS_INACTIVE_OR_FAILED(ns))
-                                job_finish_and_invalidate(u->meta.job, JOB_DONE);
-                        else if (u->meta.job->state == JOB_RUNNING && ns != UNIT_DEACTIVATING) {
+                                job_finish_and_invalidate(u->job, JOB_DONE);
+                        else if (u->job->state == JOB_RUNNING && ns != UNIT_DEACTIVATING) {
                                 unexpected = true;
-                                job_finish_and_invalidate(u->meta.job, JOB_FAILED);
+                                job_finish_and_invalidate(u->job, JOB_FAILED);
                         }
 
                         break;
@@ -1265,7 +1265,7 @@ void unit_notify(Unit *u, UnitActiveState os, UnitActiveState ns, bool reload_su
         } else
                 unexpected = true;
 
-        if (u->meta.manager->n_reloading <= 0) {
+        if (u->manager->n_reloading <= 0) {
 
                 /* If this state change happened without being
                  * requested by a job, then let's retroactively start
@@ -1286,7 +1286,7 @@ void unit_notify(Unit *u, UnitActiveState os, UnitActiveState ns, bool reload_su
                         check_unneeded_dependencies(u);
 
                 if (ns != os && ns == UNIT_FAILED) {
-                        log_notice("Unit %s entered failed state.", u->meta.id);
+                        log_notice("Unit %s entered failed state.", u->id);
                         unit_trigger_on_failure(u);
                 }
         }
@@ -1298,46 +1298,46 @@ void unit_notify(Unit *u, UnitActiveState os, UnitActiveState ns, bool reload_su
                         /* The bus just might have become available,
                          * hence try to connect to it, if we aren't
                          * yet connected. */
-                        bus_init(u->meta.manager, true);
+                        bus_init(u->manager, true);
 
-                if (u->meta.type == UNIT_SERVICE &&
+                if (u->type == UNIT_SERVICE &&
                     !UNIT_IS_ACTIVE_OR_RELOADING(os) &&
-                    u->meta.manager->n_reloading <= 0) {
+                    u->manager->n_reloading <= 0) {
                         /* Write audit record if we have just finished starting up */
-                        manager_send_unit_audit(u->meta.manager, u, AUDIT_SERVICE_START, true);
-                        u->meta.in_audit = true;
+                        manager_send_unit_audit(u->manager, u, AUDIT_SERVICE_START, true);
+                        u->in_audit = true;
                 }
 
                 if (!UNIT_IS_ACTIVE_OR_RELOADING(os))
-                        manager_send_unit_plymouth(u->meta.manager, u);
+                        manager_send_unit_plymouth(u->manager, u);
 
         } else {
 
                 /* We don't care about D-Bus here, since we'll get an
                  * asynchronous notification for it anyway. */
 
-                if (u->meta.type == UNIT_SERVICE &&
+                if (u->type == UNIT_SERVICE &&
                     UNIT_IS_INACTIVE_OR_FAILED(ns) &&
                     !UNIT_IS_INACTIVE_OR_FAILED(os) &&
-                    u->meta.manager->n_reloading <= 0) {
+                    u->manager->n_reloading <= 0) {
 
                         /* Hmm, if there was no start record written
                          * write it now, so that we always have a nice
                          * pair */
-                        if (!u->meta.in_audit) {
-                                manager_send_unit_audit(u->meta.manager, u, AUDIT_SERVICE_START, ns == UNIT_INACTIVE);
+                        if (!u->in_audit) {
+                                manager_send_unit_audit(u->manager, u, AUDIT_SERVICE_START, ns == UNIT_INACTIVE);
 
                                 if (ns == UNIT_INACTIVE)
-                                        manager_send_unit_audit(u->meta.manager, u, AUDIT_SERVICE_STOP, true);
+                                        manager_send_unit_audit(u->manager, u, AUDIT_SERVICE_STOP, true);
                         } else
                                 /* Write audit record if we have just finished shutting down */
-                                manager_send_unit_audit(u->meta.manager, u, AUDIT_SERVICE_STOP, ns == UNIT_INACTIVE);
+                                manager_send_unit_audit(u->manager, u, AUDIT_SERVICE_STOP, ns == UNIT_INACTIVE);
 
-                        u->meta.in_audit = false;
+                        u->in_audit = false;
                 }
         }
 
-        manager_recheck_syslog(u->meta.manager);
+        manager_recheck_syslog(u->manager);
 
         /* Maybe we finished startup and are now ready for being
          * stopped because unneeded? */
@@ -1359,7 +1359,7 @@ int unit_watch_fd(Unit *u, int fd, uint32_t events, Watch *w) {
         ev.data.ptr = w;
         ev.events = events;
 
-        if (epoll_ctl(u->meta.manager->epoll_fd,
+        if (epoll_ctl(u->manager->epoll_fd,
                       w->type == WATCH_INVALID ? EPOLL_CTL_ADD : EPOLL_CTL_MOD,
                       fd,
                       &ev) < 0)
@@ -1381,7 +1381,7 @@ void unit_unwatch_fd(Unit *u, Watch *w) {
 
         assert(w->type == WATCH_FD);
         assert(w->data.unit == u);
-        assert_se(epoll_ctl(u->meta.manager->epoll_fd, EPOLL_CTL_DEL, w->fd, NULL) >= 0);
+        assert_se(epoll_ctl(u->manager->epoll_fd, EPOLL_CTL_DEL, w->fd, NULL) >= 0);
 
         w->fd = -1;
         w->type = WATCH_INVALID;
@@ -1395,14 +1395,14 @@ int unit_watch_pid(Unit *u, pid_t pid) {
         /* Watch a specific PID. We only support one unit watching
          * each PID for now. */
 
-        return hashmap_put(u->meta.manager->watch_pids, LONG_TO_PTR(pid), u);
+        return hashmap_put(u->manager->watch_pids, LONG_TO_PTR(pid), u);
 }
 
 void unit_unwatch_pid(Unit *u, pid_t pid) {
         assert(u);
         assert(pid >= 1);
 
-        hashmap_remove_value(u->meta.manager->watch_pids, LONG_TO_PTR(pid), u);
+        hashmap_remove_value(u->manager->watch_pids, LONG_TO_PTR(pid), u);
 }
 
 int unit_watch_timer(Unit *u, usec_t delay, Watch *w) {
@@ -1455,7 +1455,7 @@ int unit_watch_timer(Unit *u, usec_t delay, Watch *w) {
                 ev.data.ptr = w;
                 ev.events = EPOLLIN;
 
-                if (epoll_ctl(u->meta.manager->epoll_fd, EPOLL_CTL_ADD, fd, &ev) < 0)
+                if (epoll_ctl(u->manager->epoll_fd, EPOLL_CTL_ADD, fd, &ev) < 0)
                         goto fail;
         }
 
@@ -1483,7 +1483,7 @@ void unit_unwatch_timer(Unit *u, Watch *w) {
         assert(w->data.unit == u);
         assert(w->fd >= 0);
 
-        assert_se(epoll_ctl(u->meta.manager->epoll_fd, EPOLL_CTL_DEL, w->fd, NULL) >= 0);
+        assert_se(epoll_ctl(u->manager->epoll_fd, EPOLL_CTL_DEL, w->fd, NULL) >= 0);
         close_nointr_nofail(w->fd);
 
         w->fd = -1;
@@ -1556,34 +1556,34 @@ int unit_add_dependency(Unit *u, UnitDependency d, Unit *other, bool add_referen
         if (u == other)
                 return 0;
 
-        if ((r = set_ensure_allocated(&u->meta.dependencies[d], trivial_hash_func, trivial_compare_func)) < 0)
+        if ((r = set_ensure_allocated(&u->dependencies[d], trivial_hash_func, trivial_compare_func)) < 0)
                 return r;
 
         if (inverse_table[d] != _UNIT_DEPENDENCY_INVALID)
-                if ((r = set_ensure_allocated(&other->meta.dependencies[inverse_table[d]], trivial_hash_func, trivial_compare_func)) < 0)
+                if ((r = set_ensure_allocated(&other->dependencies[inverse_table[d]], trivial_hash_func, trivial_compare_func)) < 0)
                         return r;
 
         if (add_reference)
-                if ((r = set_ensure_allocated(&u->meta.dependencies[UNIT_REFERENCES], trivial_hash_func, trivial_compare_func)) < 0 ||
-                    (r = set_ensure_allocated(&other->meta.dependencies[UNIT_REFERENCED_BY], trivial_hash_func, trivial_compare_func)) < 0)
+                if ((r = set_ensure_allocated(&u->dependencies[UNIT_REFERENCES], trivial_hash_func, trivial_compare_func)) < 0 ||
+                    (r = set_ensure_allocated(&other->dependencies[UNIT_REFERENCED_BY], trivial_hash_func, trivial_compare_func)) < 0)
                         return r;
 
-        if ((q = set_put(u->meta.dependencies[d], other)) < 0)
+        if ((q = set_put(u->dependencies[d], other)) < 0)
                 return q;
 
         if (inverse_table[d] != _UNIT_DEPENDENCY_INVALID)
-                if ((v = set_put(other->meta.dependencies[inverse_table[d]], u)) < 0) {
+                if ((v = set_put(other->dependencies[inverse_table[d]], u)) < 0) {
                         r = v;
                         goto fail;
                 }
 
         if (add_reference) {
-                if ((w = set_put(u->meta.dependencies[UNIT_REFERENCES], other)) < 0) {
+                if ((w = set_put(u->dependencies[UNIT_REFERENCES], other)) < 0) {
                         r = w;
                         goto fail;
                 }
 
-                if ((r = set_put(other->meta.dependencies[UNIT_REFERENCED_BY], u)) < 0)
+                if ((r = set_put(other->dependencies[UNIT_REFERENCED_BY], u)) < 0)
                         goto fail;
         }
 
@@ -1592,13 +1592,13 @@ int unit_add_dependency(Unit *u, UnitDependency d, Unit *other, bool add_referen
 
 fail:
         if (q > 0)
-                set_remove(u->meta.dependencies[d], other);
+                set_remove(u->dependencies[d], other);
 
         if (v > 0)
-                set_remove(other->meta.dependencies[inverse_table[d]], u);
+                set_remove(other->dependencies[inverse_table[d]], u);
 
         if (w > 0)
-                set_remove(u->meta.dependencies[UNIT_REFERENCES], other);
+                set_remove(u->dependencies[UNIT_REFERENCES], other);
 
         return r;
 }
@@ -1631,12 +1631,12 @@ static const char *resolve_template(Unit *u, const char *name, const char*path,
                 return name;
         }
 
-        if (u->meta.instance)
-                s = unit_name_replace_instance(name, u->meta.instance);
+        if (u->instance)
+                s = unit_name_replace_instance(name, u->instance);
         else {
                 char *i;
 
-                if (!(i = unit_name_to_prefix(u->meta.id)))
+                if (!(i = unit_name_to_prefix(u->id)))
                         return NULL;
 
                 s = unit_name_replace_instance(name, i);
@@ -1661,7 +1661,7 @@ int unit_add_dependency_by_name(Unit *u, UnitDependency d, const char *name, con
         if (!(name = resolve_template(u, name, path, &s)))
                 return -ENOMEM;
 
-        if ((r = manager_load_unit(u->meta.manager, name, path, NULL, &other)) < 0)
+        if ((r = manager_load_unit(u->manager, name, path, NULL, &other)) < 0)
                 goto finish;
 
         r = unit_add_dependency(u, d, other, add_reference);
@@ -1682,7 +1682,7 @@ int unit_add_two_dependencies_by_name(Unit *u, UnitDependency d, UnitDependency
         if (!(name = resolve_template(u, name, path, &s)))
                 return -ENOMEM;
 
-        if ((r = manager_load_unit(u->meta.manager, name, path, NULL, &other)) < 0)
+        if ((r = manager_load_unit(u->manager, name, path, NULL, &other)) < 0)
                 goto finish;
 
         r = unit_add_two_dependencies(u, d, e, other, add_reference);
@@ -1703,7 +1703,7 @@ int unit_add_dependency_by_name_inverse(Unit *u, UnitDependency d, const char *n
         if (!(name = resolve_template(u, name, path, &s)))
                 return -ENOMEM;
 
-        if ((r = manager_load_unit(u->meta.manager, name, path, NULL, &other)) < 0)
+        if ((r = manager_load_unit(u->manager, name, path, NULL, &other)) < 0)
                 goto finish;
 
         r = unit_add_dependency(other, d, u, add_reference);
@@ -1724,7 +1724,7 @@ int unit_add_two_dependencies_by_name_inverse(Unit *u, UnitDependency d, UnitDep
         if (!(name = resolve_template(u, name, path, &s)))
                 return -ENOMEM;
 
-        if ((r = manager_load_unit(u->meta.manager, name, path, NULL, &other)) < 0)
+        if ((r = manager_load_unit(u->manager, name, path, NULL, &other)) < 0)
                 goto finish;
 
         if ((r = unit_add_two_dependencies(other, d, e, u, add_reference)) < 0)
@@ -1769,10 +1769,10 @@ char *unit_dbus_path(Unit *u) {
 
         assert(u);
 
-        if (!u->meta.id)
+        if (!u->id)
                 return NULL;
 
-        if (!(e = bus_path_escape(u->meta.id)))
+        if (!(e = bus_path_escape(u->id)))
                 return NULL;
 
         p = strappend("/org/freedesktop/systemd1/unit/", e);
@@ -1802,16 +1802,16 @@ int unit_add_cgroup(Unit *u, CGroupBonding *b) {
         if (streq(b->controller, SYSTEMD_CGROUP_CONTROLLER)) {
                 CGroupBonding *l;
 
-                l = hashmap_get(u->meta.manager->cgroup_bondings, b->path);
+                l = hashmap_get(u->manager->cgroup_bondings, b->path);
                 LIST_PREPEND(CGroupBonding, by_path, l, b);
 
-                if ((r = hashmap_replace(u->meta.manager->cgroup_bondings, b->path, l)) < 0) {
+                if ((r = hashmap_replace(u->manager->cgroup_bondings, b->path, l)) < 0) {
                         LIST_REMOVE(CGroupBonding, by_path, l, b);
                         return r;
                 }
         }
 
-        LIST_PREPEND(CGroupBonding, by_unit, u->meta.cgroup_bondings, b);
+        LIST_PREPEND(CGroupBonding, by_unit, u->cgroup_bondings, b);
         b->unit = u;
 
         return 0;
@@ -1822,17 +1822,17 @@ static char *default_cgroup_path(Unit *u) {
 
         assert(u);
 
-        if (u->meta.instance) {
+        if (u->instance) {
                 char *t;
 
-                t = unit_name_template(u->meta.id);
+                t = unit_name_template(u->id);
                 if (!t)
                         return NULL;
 
-                p = join(u->meta.manager->cgroup_hierarchy, "/", t, "/", u->meta.instance, NULL);
+                p = join(u->manager->cgroup_hierarchy, "/", t, "/", u->instance, NULL);
                 free(t);
         } else
-                p = join(u->meta.manager->cgroup_hierarchy, "/", u->meta.id, NULL);
+                p = join(u->manager->cgroup_hierarchy, "/", u->id, NULL);
 
         return p;
 }
@@ -1866,7 +1866,7 @@ int unit_add_cgroup_from_text(Unit *u, const char *name) {
                 return -ENOMEM;
         }
 
-        if (cgroup_bonding_find_list(u->meta.cgroup_bondings, controller)) {
+        if (cgroup_bonding_find_list(u->cgroup_bondings, controller)) {
                 r = -EEXIST;
                 goto fail;
         }
@@ -1903,7 +1903,7 @@ static int unit_add_one_default_cgroup(Unit *u, const char *controller) {
         if (!controller)
                 controller = SYSTEMD_CGROUP_CONTROLLER;
 
-        if (cgroup_bonding_find_list(u->meta.cgroup_bondings, controller))
+        if (cgroup_bonding_find_list(u->cgroup_bondings, controller))
                 return 0;
 
         if (!(b = new0(CGroupBonding, 1)))
@@ -1941,16 +1941,16 @@ int unit_add_default_cgroups(Unit *u) {
         /* Adds in the default cgroups, if they weren't specified
          * otherwise. */
 
-        if (!u->meta.manager->cgroup_hierarchy)
+        if (!u->manager->cgroup_hierarchy)
                 return 0;
 
         if ((r = unit_add_one_default_cgroup(u, NULL)) < 0)
                 return r;
 
-        STRV_FOREACH(c, u->meta.manager->default_controllers)
+        STRV_FOREACH(c, u->manager->default_controllers)
                 unit_add_one_default_cgroup(u, *c);
 
-        LIST_FOREACH(by_unit, a, u->meta.cgroup_attributes)
+        LIST_FOREACH(by_unit, a, u->cgroup_attributes)
                 unit_add_one_default_cgroup(u, a->controller);
 
         return 0;
@@ -1959,7 +1959,7 @@ int unit_add_default_cgroups(Unit *u) {
 CGroupBonding* unit_get_default_cgroup(Unit *u) {
         assert(u);
 
-        return cgroup_bonding_find_list(u->meta.cgroup_bondings, SYSTEMD_CGROUP_CONTROLLER);
+        return cgroup_bonding_find_list(u->cgroup_bondings, SYSTEMD_CGROUP_CONTROLLER);
 }
 
 int unit_add_cgroup_attribute(Unit *u, const char *controller, const char *name, const char *value, CGroupAttributeMapCallback map_callback) {
@@ -2016,7 +2016,7 @@ int unit_add_cgroup_attribute(Unit *u, const char *controller, const char *name,
 
         a->map_callback = map_callback;
 
-        LIST_PREPEND(CGroupAttribute, by_unit, u->meta.cgroup_attributes, a);
+        LIST_PREPEND(CGroupAttribute, by_unit, u->cgroup_attributes, a);
 
         r = 0;
 
@@ -2033,12 +2033,12 @@ int unit_load_related_unit(Unit *u, const char *type, Unit **_found) {
         assert(type);
         assert(_found);
 
-        if (!(t = unit_name_change_suffix(u->meta.id, type)))
+        if (!(t = unit_name_change_suffix(u->id, type)))
                 return -ENOMEM;
 
         assert(!unit_has_name(u, t));
 
-        r = manager_load_unit(u->meta.manager, t, NULL, NULL, _found);
+        r = manager_load_unit(u->manager, t, NULL, NULL, _found);
         free(t);
 
         assert(r < 0 || *_found != u);
@@ -2054,12 +2054,12 @@ int unit_get_related_unit(Unit *u, const char *type, Unit **_found) {
         assert(type);
         assert(_found);
 
-        if (!(t = unit_name_change_suffix(u->meta.id, type)))
+        if (!(t = unit_name_change_suffix(u->id, type)))
                 return -ENOMEM;
 
         assert(!unit_has_name(u, t));
 
-        found = manager_get_unit(u->meta.manager, t);
+        found = manager_get_unit(u->manager, t);
         free(t);
 
         if (!found)
@@ -2073,14 +2073,14 @@ static char *specifier_prefix_and_instance(char specifier, void *data, void *use
         Unit *u = userdata;
         assert(u);
 
-        return unit_name_to_prefix_and_instance(u->meta.id);
+        return unit_name_to_prefix_and_instance(u->id);
 }
 
 static char *specifier_prefix(char specifier, void *data, void *userdata) {
         Unit *u = userdata;
         assert(u);
 
-        return unit_name_to_prefix(u->meta.id);
+        return unit_name_to_prefix(u->id);
 }
 
 static char *specifier_prefix_unescaped(char specifier, void *data, void *userdata) {
@@ -2089,7 +2089,7 @@ static char *specifier_prefix_unescaped(char specifier, void *data, void *userda
 
         assert(u);
 
-        if (!(p = unit_name_to_prefix(u->meta.id)))
+        if (!(p = unit_name_to_prefix(u->id)))
                 return NULL;
 
         r = unit_name_unescape(p);
@@ -2102,8 +2102,8 @@ static char *specifier_instance_unescaped(char specifier, void *data, void *user
         Unit *u = userdata;
         assert(u);
 
-        if (u->meta.instance)
-                return unit_name_unescape(u->meta.instance);
+        if (u->instance)
+                return unit_name_unescape(u->instance);
 
         return strdup("");
 }
@@ -2112,10 +2112,10 @@ static char *specifier_filename(char specifier, void *data, void *userdata) {
         Unit *u = userdata;
         assert(u);
 
-        if (u->meta.instance)
-                return unit_name_path_unescape(u->meta.instance);
+        if (u->instance)
+                return unit_name_path_unescape(u->instance);
 
-        return unit_name_to_path(u->meta.instance);
+        return unit_name_to_path(u->instance);
 }
 
 static char *specifier_cgroup(char specifier, void *data, void *userdata) {
@@ -2131,9 +2131,9 @@ static char *specifier_cgroup_root(char specifier, void *data, void *userdata) {
         assert(u);
 
         if (specifier == 'r')
-                return strdup(u->meta.manager->cgroup_hierarchy);
+                return strdup(u->manager->cgroup_hierarchy);
 
-        if (parent_of_path(u->meta.manager->cgroup_hierarchy, &p) < 0)
+        if (parent_of_path(u->manager->cgroup_hierarchy, &p) < 0)
                 return strdup("");
 
         if (streq(p, "/")) {
@@ -2148,7 +2148,7 @@ static char *specifier_runtime(char specifier, void *data, void *userdata) {
         Unit *u = userdata;
         assert(u);
 
-        if (u->meta.manager->running_as == MANAGER_USER) {
+        if (u->manager->running_as == MANAGER_USER) {
                 const char *e;
 
                 e = getenv("XDG_RUNTIME_DIR");
@@ -2172,10 +2172,10 @@ char *unit_name_printf(Unit *u, const char* format) {
          */
 
         const Specifier table[] = {
-                { 'n', specifier_string,              u->meta.id },
+                { 'n', specifier_string,              u->id },
                 { 'N', specifier_prefix_and_instance, NULL },
                 { 'p', specifier_prefix,              NULL },
-                { 'i', specifier_string,              u->meta.instance },
+                { 'i', specifier_string,              u->instance },
                 { 0, NULL, NULL }
         };
 
@@ -2197,11 +2197,11 @@ char *unit_full_printf(Unit *u, const char *format) {
          */
 
         const Specifier table[] = {
-                { 'n', specifier_string,              u->meta.id },
+                { 'n', specifier_string,              u->id },
                 { 'N', specifier_prefix_and_instance, NULL },
                 { 'p', specifier_prefix,              NULL },
                 { 'P', specifier_prefix_unescaped,    NULL },
-                { 'i', specifier_string,              u->meta.instance },
+                { 'i', specifier_string,              u->instance },
                 { 'I', specifier_instance_unescaped,  NULL },
                 { 'f', specifier_filename,            NULL },
                 { 'c', specifier_cgroup,              NULL },
@@ -2252,14 +2252,14 @@ int unit_watch_bus_name(Unit *u, const char *name) {
         /* Watch a specific name on the bus. We only support one unit
          * watching each name for now. */
 
-        return hashmap_put(u->meta.manager->watch_bus, name, u);
+        return hashmap_put(u->manager->watch_bus, name, u);
 }
 
 void unit_unwatch_bus_name(Unit *u, const char *name) {
         assert(u);
         assert(name);
 
-        hashmap_remove_value(u->meta.manager->watch_bus, name, u);
+        hashmap_remove_value(u->manager->watch_bus, name, u);
 }
 
 bool unit_can_serialize(Unit *u) {
@@ -2281,17 +2281,17 @@ int unit_serialize(Unit *u, FILE *f, FDSet *fds) {
         if ((r = UNIT_VTABLE(u)->serialize(u, f, fds)) < 0)
                 return r;
 
-        if (u->meta.job)
-                unit_serialize_item(u, f, "job", job_type_to_string(u->meta.job->type));
+        if (u->job)
+                unit_serialize_item(u, f, "job", job_type_to_string(u->job->type));
 
-        dual_timestamp_serialize(f, "inactive-exit-timestamp", &u->meta.inactive_exit_timestamp);
-        dual_timestamp_serialize(f, "active-enter-timestamp", &u->meta.active_enter_timestamp);
-        dual_timestamp_serialize(f, "active-exit-timestamp", &u->meta.active_exit_timestamp);
-        dual_timestamp_serialize(f, "inactive-enter-timestamp", &u->meta.inactive_enter_timestamp);
-        dual_timestamp_serialize(f, "condition-timestamp", &u->meta.condition_timestamp);
+        dual_timestamp_serialize(f, "inactive-exit-timestamp", &u->inactive_exit_timestamp);
+        dual_timestamp_serialize(f, "active-enter-timestamp", &u->active_enter_timestamp);
+        dual_timestamp_serialize(f, "active-exit-timestamp", &u->active_exit_timestamp);
+        dual_timestamp_serialize(f, "inactive-enter-timestamp", &u->inactive_enter_timestamp);
+        dual_timestamp_serialize(f, "condition-timestamp", &u->condition_timestamp);
 
-        if (dual_timestamp_is_set(&u->meta.condition_timestamp))
-                unit_serialize_item(u, f, "condition-result", yes_no(u->meta.condition_result));
+        if (dual_timestamp_is_set(&u->condition_timestamp))
+                unit_serialize_item(u, f, "condition-result", yes_no(u->condition_result));
 
         /* End marker */
         fputc('\n', f);
@@ -2366,23 +2366,23 @@ int unit_deserialize(Unit *u, FILE *f, FDSet *fds) {
                         if ((type = job_type_from_string(v)) < 0)
                                 log_debug("Failed to parse job type value %s", v);
                         else
-                                u->meta.deserialized_job = type;
+                                u->deserialized_job = type;
 
                         continue;
                 } else if (streq(l, "inactive-exit-timestamp")) {
-                        dual_timestamp_deserialize(v, &u->meta.inactive_exit_timestamp);
+                        dual_timestamp_deserialize(v, &u->inactive_exit_timestamp);
                         continue;
                 } else if (streq(l, "active-enter-timestamp")) {
-                        dual_timestamp_deserialize(v, &u->meta.active_enter_timestamp);
+                        dual_timestamp_deserialize(v, &u->active_enter_timestamp);
                         continue;
                 } else if (streq(l, "active-exit-timestamp")) {
-                        dual_timestamp_deserialize(v, &u->meta.active_exit_timestamp);
+                        dual_timestamp_deserialize(v, &u->active_exit_timestamp);
                         continue;
                 } else if (streq(l, "inactive-enter-timestamp")) {
-                        dual_timestamp_deserialize(v, &u->meta.inactive_enter_timestamp);
+                        dual_timestamp_deserialize(v, &u->inactive_enter_timestamp);
                         continue;
                 } else if (streq(l, "condition-timestamp")) {
-                        dual_timestamp_deserialize(v, &u->meta.condition_timestamp);
+                        dual_timestamp_deserialize(v, &u->condition_timestamp);
                         continue;
                 } else if (streq(l, "condition-result")) {
                         int b;
@@ -2390,7 +2390,7 @@ int unit_deserialize(Unit *u, FILE *f, FDSet *fds) {
                         if ((b = parse_boolean(v)) < 0)
                                 log_debug("Failed to parse condition result value %s", v);
                         else
-                                u->meta.condition_result = b;
+                                u->condition_result = b;
 
                         continue;
                 }
@@ -2418,7 +2418,7 @@ int unit_add_node_link(Unit *u, const char *what, bool wants) {
         if (!(e = unit_name_build_escape(what+1, NULL, ".device")))
                 return -ENOMEM;
 
-        r = manager_load_unit(u->meta.manager, e, NULL, NULL, &device);
+        r = manager_load_unit(u->manager, e, NULL, NULL, &device);
         free(e);
 
         if (r < 0)
@@ -2443,11 +2443,11 @@ int unit_coldplug(Unit *u) {
                 if ((r = UNIT_VTABLE(u)->coldplug(u)) < 0)
                         return r;
 
-        if (u->meta.deserialized_job >= 0) {
-                if ((r = manager_add_job(u->meta.manager, u->meta.deserialized_job, u, JOB_IGNORE_REQUIREMENTS, false, NULL, NULL)) < 0)
+        if (u->deserialized_job >= 0) {
+                if ((r = manager_add_job(u->manager, u->deserialized_job, u, JOB_IGNORE_REQUIREMENTS, false, NULL, NULL)) < 0)
                         return r;
 
-                u->meta.deserialized_job = _JOB_TYPE_INVALID;
+                u->deserialized_job = _JOB_TYPE_INVALID;
         }
 
         return 0;
@@ -2462,10 +2462,10 @@ void unit_status_printf(Unit *u, const char *status, const char *format, ...) {
         if (!UNIT_VTABLE(u)->show_status)
                 return;
 
-        if (!manager_get_show_status(u->meta.manager))
+        if (!manager_get_show_status(u->manager))
                 return;
 
-        if (!manager_is_booting_or_shutting_down(u->meta.manager))
+        if (!manager_is_booting_or_shutting_down(u->manager))
                 return;
 
         va_start(ap, format);
@@ -2476,16 +2476,16 @@ void unit_status_printf(Unit *u, const char *status, const char *format, ...) {
 bool unit_need_daemon_reload(Unit *u) {
         assert(u);
 
-        if (u->meta.fragment_path) {
+        if (u->fragment_path) {
                 struct stat st;
 
                 zero(st);
-                if (stat(u->meta.fragment_path, &st) < 0)
+                if (stat(u->fragment_path, &st) < 0)
                         /* What, cannot access this anymore? */
                         return true;
 
-                if (u->meta.fragment_mtime > 0 &&
-                    timespec_load(&st.st_mtim) != u->meta.fragment_mtime)
+                if (u->fragment_mtime > 0 &&
+                    timespec_load(&st.st_mtim) != u->fragment_mtime)
                         return true;
         }
 
@@ -2519,7 +2519,7 @@ bool unit_pending_inactive(Unit *u) {
         if (UNIT_IS_INACTIVE_OR_DEACTIVATING(unit_active_state(u)))
                 return true;
 
-        if (u->meta.job && u->meta.job->type == JOB_STOP)
+        if (u->job && u->job->type == JOB_STOP)
                 return true;
 
         return false;
@@ -2533,10 +2533,10 @@ bool unit_pending_active(Unit *u) {
         if (UNIT_IS_ACTIVE_OR_ACTIVATING(unit_active_state(u)))
                 return true;
 
-        if (u->meta.job &&
-            (u->meta.job->type == JOB_START ||
-             u->meta.job->type == JOB_RELOAD_OR_START ||
-             u->meta.job->type == JOB_RESTART))
+        if (u->job &&
+            (u->job->type == JOB_START ||
+             u->job->type == JOB_RELOAD_OR_START ||
+             u->job->type == JOB_RESTART))
                 return true;
 
         return false;
@@ -2594,12 +2594,12 @@ int unit_following_set(Unit *u, Set **s) {
 UnitFileState unit_get_unit_file_state(Unit *u) {
         assert(u);
 
-        if (u->meta.unit_file_state < 0 && u->meta.fragment_path)
-                u->meta.unit_file_state = unit_file_get_state(
-                                u->meta.manager->running_as == MANAGER_SYSTEM ? UNIT_FILE_SYSTEM : UNIT_FILE_USER,
-                                NULL, file_name_from_path(u->meta.fragment_path));
+        if (u->unit_file_state < 0 && u->fragment_path)
+                u->unit_file_state = unit_file_get_state(
+                                u->manager->running_as == MANAGER_SYSTEM ? UNIT_FILE_SYSTEM : UNIT_FILE_USER,
+                                NULL, file_name_from_path(u->fragment_path));
 
-        return u->meta.unit_file_state;
+        return u->unit_file_state;
 }
 
 Unit* unit_ref_set(UnitRef *ref, Unit *u) {
@@ -2610,7 +2610,7 @@ Unit* unit_ref_set(UnitRef *ref, Unit *u) {
                 unit_ref_unset(ref);
 
         ref->unit = u;
-        LIST_PREPEND(UnitRef, refs, u->meta.refs, ref);
+        LIST_PREPEND(UnitRef, refs, u->refs, ref);
         return u;
 }
 
@@ -2620,7 +2620,7 @@ void unit_ref_unset(UnitRef *ref) {
         if (!ref->unit)
                 return;
 
-        LIST_REMOVE(UnitRef, refs, ref->unit->meta.refs, ref);
+        LIST_REMOVE(UnitRef, refs, ref->unit->refs, ref);
         ref->unit = NULL;
 }
 
diff --git a/src/unit.h b/src/unit.h
index 626bdc4..756f465 100644
--- a/src/unit.h
+++ b/src/unit.h
@@ -25,8 +25,7 @@
 #include <stdbool.h>
 #include <stdlib.h>
 
-typedef union Unit Unit;
-typedef struct Meta Meta;
+typedef struct Unit Unit;
 typedef struct UnitVTable UnitVTable;
 typedef enum UnitType UnitType;
 typedef enum UnitLoadState UnitLoadState;
@@ -141,7 +140,7 @@ enum UnitDependency {
 #include "cgroup.h"
 #include "cgroup-attr.h"
 
-struct Meta {
+struct Unit {
         Manager *manager;
 
         UnitType type;
@@ -183,19 +182,19 @@ struct Meta {
         CGroupAttribute *cgroup_attributes;
 
         /* Per type list */
-        LIST_FIELDS(Meta, units_by_type);
+        LIST_FIELDS(Unit, units_by_type);
 
         /* Load queue */
-        LIST_FIELDS(Meta, load_queue);
+        LIST_FIELDS(Unit, load_queue);
 
         /* D-Bus queue */
-        LIST_FIELDS(Meta, dbus_queue);
+        LIST_FIELDS(Unit, dbus_queue);
 
         /* Cleanup queue */
-        LIST_FIELDS(Meta, cleanup_queue);
+        LIST_FIELDS(Unit, cleanup_queue);
 
         /* GC queue */
-        LIST_FIELDS(Meta, gc_queue);
+        LIST_FIELDS(Unit, gc_queue);
 
         /* Used during GC sweeps */
         unsigned gc_marker;
@@ -269,20 +268,6 @@ struct UnitRef {
 #include "swap.h"
 #include "path.h"
 
-union Unit {
-        Meta meta;
-        Service service;
-        Timer timer;
-        Socket socket;
-        Target target;
-        Device device;
-        Mount mount;
-        Automount automount;
-        Snapshot snapshot;
-        Swap swap;
-        Path path;
-};
-
 struct UnitVTable {
         const char *suffix;
 
@@ -413,19 +398,19 @@ struct UnitVTable {
 
 extern const UnitVTable * const unit_vtable[_UNIT_TYPE_MAX];
 
-#define UNIT_VTABLE(u) unit_vtable[(u)->meta.type]
+#define UNIT_VTABLE(u) unit_vtable[(u)->type]
 
 /* For casting a unit into the various unit types */
 #define DEFINE_CAST(UPPERCASE, MixedCase)                               \
         static inline MixedCase* UPPERCASE(Unit *u) {                   \
-                if (_unlikely_(!u || u->meta.type != UNIT_##UPPERCASE)) \
+                if (_unlikely_(!u || u->type != UNIT_##UPPERCASE))      \
                         return NULL;                                    \
                                                                         \
                 return (MixedCase*) u;                                  \
         }
 
 /* For casting the various unit types into a unit */
-#define UNIT(u) ((Unit*) (&(u)->meta))
+#define UNIT(u) (&(u)->meta)
 
 DEFINE_CAST(SOCKET, Socket);
 DEFINE_CAST(TIMER, Timer);
