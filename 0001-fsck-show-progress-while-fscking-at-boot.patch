From 27d340c772fb1b251085dba7bd5420484f7c5892 Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Thu, 1 Sep 2011 21:05:06 +0200
Subject: [PATCH] fsck: show progress while fscking at boot

---

[fixed up a small reject -- michich]

Index: systemd-26/src/fsck.c
===================================================================
--- systemd-26.orig/src/fsck.c
+++ systemd-26/src/fsck.c
@@ -25,6 +25,7 @@
 #include <errno.h>
 #include <unistd.h>
 #include <fcntl.h>
+#include <sys/file.h>
 
 #include <libudev.h>
 #include <dbus/dbus.h>
@@ -36,6 +37,7 @@
 
 static bool arg_skip = false;
 static bool arg_force = false;
+static bool arg_show_progress = false;
 
 static void start_target(const char *target, bool isolate) {
         DBusMessage *m = NULL, *reply = NULL;
@@ -142,10 +144,103 @@ static void test_files(void) {
 
         if (access("/forcefsck", F_OK) >= 0)
                 arg_force = true;
+
+        if (access("/run/systemd/show-status", F_OK) >= 0 || plymouth_running())
+                arg_show_progress = true;
+}
+
+static double percent(int pass, unsigned long cur, unsigned long max) {
+        /* Values stolen from e2fsck */
+
+        static const int pass_table[] = {
+                0, 70, 90, 92, 95, 100
+        };
+
+        if (pass <= 0)
+                return 0.0;
+
+        if ((unsigned) pass >= ELEMENTSOF(pass_table) || max == 0)
+                return 100.0;
+
+        return (double) pass_table[pass-1] +
+                ((double) pass_table[pass] - (double) pass_table[pass-1]) *
+                (double) cur / (double) max;
+}
+
+static int process_progress(int fd) {
+        FILE *f, *console;
+        usec_t last = 0;
+        bool locked = false;
+        int clear = 0;
+
+        f = fdopen(fd, "r");
+        if (!f) {
+                close_nointr_nofail(fd);
+                return -errno;
+        }
+
+        console = fopen("/dev/console", "w");
+        if (!console) {
+                fclose(f);
+                return -ENOMEM;
+        }
+
+        while (!feof(f)) {
+                int pass, m;
+                unsigned long cur, max;
+                char *device;
+                double p;
+                usec_t t;
+
+                if (fscanf(f, "%i %lu %lu %ms", &pass, &cur, &max, &device) != 4)
+                        break;
+
+                /* Only show one progress counter at max */
+                if (!locked) {
+                        if (flock(fileno(console), LOCK_EX|LOCK_NB) < 0) {
+                                free(device);
+                                continue;
+                        }
+
+                        locked = true;
+                }
+
+                /* Only update once every 50ms */
+                t = now(CLOCK_MONOTONIC);
+                if (last + 50 * USEC_PER_MSEC > t)  {
+                        free(device);
+                        continue;
+                }
+
+                last = t;
+
+                p = percent(pass, cur, max);
+                fprintf(console, "\r%s: fsck %3.1f%% complete...\r%n", device, p, &m);
+                fflush(console);
+
+                free(device);
+
+                if (m > clear)
+                        clear = m;
+        }
+
+        if (clear > 0) {
+                unsigned j;
+
+                fputc('\r', console);
+                for (j = 0; j < (unsigned) clear; j++)
+                        fputc(' ', console);
+                fputc('\r', console);
+                fflush(console);
+        }
+
+        fclose(f);
+        fclose(console);
+        return 0;
 }
 
 int main(int argc, char *argv[]) {
-        const char *cmdline[8];
+        const char *cmdline[9];
         int i = 0, r = EXIT_FAILURE, q;
         pid_t pid;
         siginfo_t status;
@@ -153,13 +248,15 @@ int main(int argc, char *argv[]) {
         struct udev_device *udev_device = NULL;
         const char *device;
         bool root_directory;
+        int progress_pipe[2] = { -1, -1 };
+        char dash_c[2+10+1];
 
         if (argc > 2) {
                 log_error("This program expects one or no arguments.");
                 return EXIT_FAILURE;
         }
 
-        log_set_target(LOG_TARGET_SYSLOG_OR_KMSG);
+        log_set_target(LOG_TARGET_AUTO);
         log_parse_environment();
         log_open();
 
@@ -213,6 +310,12 @@ int main(int argc, char *argv[]) {
                 root_directory = true;
         }
 
+        if (arg_show_progress)
+                if (pipe(progress_pipe) < 0) {
+                        log_error("pipe(): %m");
+                        goto finish;
+                }
+
         cmdline[i++] = "/sbin/fsck";
         cmdline[i++] = "-a";
         cmdline[i++] = "-T";
@@ -224,19 +327,39 @@ int main(int argc, char *argv[]) {
         if (arg_force)
                 cmdline[i++] = "-f";
 
+        if (progress_pipe[1] >= 0) {
+                snprintf(dash_c, sizeof(dash_c), "-C%i", progress_pipe[1]);
+                char_array_0(dash_c);
+                cmdline[i++] = dash_c;
+        }
+
         cmdline[i++] = device;
         cmdline[i++] = NULL;
 
-        if ((pid = fork()) < 0) {
+        pid = fork();
+        if (pid < 0) {
                 log_error("fork(): %m");
                 goto finish;
         } else if (pid == 0) {
                 /* Child */
+                if (progress_pipe[0] >= 0)
+                        close_nointr_nofail(progress_pipe[0]);
                 execv(cmdline[0], (char**) cmdline);
                 _exit(8); /* Operational error */
         }
 
-        if ((q = wait_for_terminate(pid, &status)) < 0) {
+        if (progress_pipe[1] >= 0) {
+                close_nointr_nofail(progress_pipe[1]);
+                progress_pipe[1] = -1;
+        }
+
+        if (progress_pipe[0] >= 0) {
+                process_progress(progress_pipe[0]);
+                progress_pipe[0] = -1;
+        }
+
+        q = wait_for_terminate(pid, &status);
+        if (q < 0) {
                 log_error("waitid(): %s", strerror(-q));
                 goto finish;
         }
@@ -274,5 +397,7 @@ finish:
         if (udev)
                 udev_unref(udev);
 
+        close_pipe(progress_pipe);
+
         return r;
 }
Index: systemd-26/src/main.c
===================================================================
--- systemd-26.orig/src/main.c
+++ systemd-26/src/main.c
@@ -1194,7 +1194,6 @@ int main(int argc, char *argv[]) {
         }
 
         m->confirm_spawn = arg_confirm_spawn;
-        m->show_status = arg_show_status;
 #ifdef HAVE_SYSV_COMPAT
         m->sysv_console = arg_sysv_console;
 #endif
@@ -1209,6 +1208,8 @@ int main(int argc, char *argv[]) {
         if (arg_default_controllers)
                 manager_set_default_controllers(m, arg_default_controllers);
 
+        manager_set_show_status(m, arg_show_status);
+
         if ((r = manager_startup(m, serialization, fds)) < 0)
                 log_error("Failed to fully start up daemon: %s", strerror(-r));
 
Index: systemd-26/src/manager.c
===================================================================
--- systemd-26.orig/src/manager.c
+++ systemd-26/src/manager.c
@@ -2241,12 +2241,12 @@ static int manager_process_signal_fd(Man
 
                         case 20:
                                 log_debug("Enabling showing of status.");
-                                m->show_status = true;
+                                manager_set_show_status(m, true);
                                 break;
 
                         case 21:
                                 log_debug("Disabling showing of status.");
-                                m->show_status = false;
+                                manager_set_show_status(m, false);
                                 break;
 
                         case 22:
@@ -2897,7 +2897,8 @@ bool manager_is_booting_or_shutting_down
                 return true;
 
         /* Is there a job for the shutdown target? */
-        if (((u = manager_get_unit(m, SPECIAL_SHUTDOWN_TARGET))))
+        u = manager_get_unit(m, SPECIAL_SHUTDOWN_TARGET);
+        if (u)
                 return !!u->meta.job;
 
         return false;
@@ -3114,6 +3115,35 @@ void manager_recheck_syslog(Manager *m) 
         log_open();
 }
 
+void manager_set_show_status(Manager *m, bool b) {
+        assert(m);
+
+        if (m->running_as != MANAGER_SYSTEM)
+                return;
+
+        m->show_status = b;
+
+        if (b)
+                touch("/run/systemd/show-status");
+        else
+                unlink("/run/systemd/show-status");
+}
+
+bool manager_get_show_status(Manager *m) {
+        assert(m);
+
+        if (m->running_as != MANAGER_SYSTEM)
+                return false;
+
+        if (m->show_status)
+                return true;
+
+        /* If Plymouth is running make sure we show the status, so
+         * that there's something nice to see when people press Esc */
+
+        return plymouth_running();
+}
+
 static const char* const manager_running_as_table[_MANAGER_RUNNING_AS_MAX] = {
         [MANAGER_SYSTEM] = "system",
         [MANAGER_USER] = "user"
Index: systemd-26/src/manager.h
===================================================================
--- systemd-26.orig/src/manager.h
+++ systemd-26/src/manager.h
@@ -290,6 +290,9 @@ void manager_undo_generators(Manager *m)
 
 void manager_recheck_syslog(Manager *m);
 
+void manager_set_show_status(Manager *m, bool b);
+bool manager_get_show_status(Manager *m);
+
 const char *manager_running_as_to_string(ManagerRunningAs i);
 ManagerRunningAs manager_running_as_from_string(const char *s);
 
Index: systemd-26/src/unit.c
===================================================================
--- systemd-26.orig/src/unit.c
+++ systemd-26/src/unit.c
@@ -2285,13 +2285,7 @@ void unit_status_printf(Unit *u, const c
         if (!UNIT_VTABLE(u)->show_status)
                 return;
 
-        if (u->meta.manager->running_as != MANAGER_SYSTEM)
-                return;
-
-        /* If Plymouth is running make sure we show the status, so
-         * that there's something nice to see when people press Esc */
-
-        if (!u->meta.manager->show_status && !plymouth_running())
+        if (!manager_get_show_status(u->meta.manager))
                 return;
 
         if (!manager_is_booting_or_shutting_down(u->meta.manager))
