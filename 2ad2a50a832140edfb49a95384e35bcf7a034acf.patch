From 2ad2a50a832140edfb49a95384e35bcf7a034acf Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Thu, 11 Mar 2021 21:49:44 +0100
Subject: [PATCH] syscall: disable epoll_pwait2() for now on 32bit

Alternative to #18973.
---
 src/basic/missing_syscall.h | 8 ++++++++
 1 file changed, 8 insertions(+)

diff --git a/src/basic/missing_syscall.h b/src/basic/missing_syscall.h
index 13843248045..8bbe4d28847 100644
--- a/src/basic/missing_syscall.h
+++ b/src/basic/missing_syscall.h
@@ -407,6 +407,13 @@ static inline int missing_epoll_pwait2(
                 const sigset_t *sigset) {
 
 #  if defined(__NR_epoll_pwait2) && HAVE_LINUX_TIME_TYPES_H
+#    if __SIZEOF_LONG__ == 4
+        /* Someone with an interest in 32bit systems, please have a look at this, and figure out why
+         * this hangs on 32bit systems. My educated guess: might be because of issues with the
+         * __kernel_timespec translation or because of incorrectly sized sigset_t array. */
+        errno = ENOSYS;
+        return -1;
+#    else
         if (timeout) {
                 /* Convert from userspace timespec to kernel timespec */
                 struct __kernel_timespec ts = {
@@ -417,6 +424,7 @@ static inline int missing_epoll_pwait2(
                 return syscall(__NR_epoll_pwait2, fd, events, maxevents, &ts, sigset, sigset ? KERNEL_NSIG_BYTES : 0);
         } else
                 return syscall(__NR_epoll_pwait2, fd, events, maxevents, NULL, sigset, sigset ? KERNEL_NSIG_BYTES : 0);
+#    endif
 #  else
         errno = ENOSYS;
         return -1;
