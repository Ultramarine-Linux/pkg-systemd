From 0d014d3d44eafe414dd60830f39bc47bad8319d3 Mon Sep 17 00:00:00 2001
From: Daniel Mack <daniel@zonque.org>
Date: Tue, 21 Jul 2015 15:30:47 +0200
Subject: [PATCH] bootchart: fix negative 'timeleft' condition

Fix the overrun case in sample acquistion and negative number calculations.

Reported by Stefan Sauer.

Fixes #642

(cherry picked from commit 0a327854f8613b7a52a80c1f3f8fc3100fb9df58)
---
 src/bootchart/bootchart.c | 16 ++++++----------
 1 file changed, 6 insertions(+), 10 deletions(-)

diff --git a/src/bootchart/bootchart.c b/src/bootchart/bootchart.c
index 175be68688..88bd4d7943 100644
--- a/src/bootchart/bootchart.c
+++ b/src/bootchart/bootchart.c
@@ -383,9 +383,6 @@ int main(int argc, char *argv[]) {
         for (samples = 0; !exiting && samples < arg_samples_len; samples++) {
                 int res;
                 double sample_stop;
-                struct timespec req;
-                time_t newint_s;
-                long newint_ns;
                 double elapsed;
                 double timeleft;
 
@@ -426,18 +423,17 @@ int main(int argc, char *argv[]) {
                 elapsed = (sample_stop - sampledata->sampletime) * 1000000000.0;
                 timeleft = interval - elapsed;
 
-                newint_s = (time_t)(timeleft / 1000000000.0);
-                newint_ns = (long)(timeleft - (newint_s * 1000000000.0));
-
                 /*
                  * check if we have not consumed our entire timeslice. If we
                  * do, don't sleep and take a new sample right away.
                  * we'll lose all the missed samples and overrun our total
                  * time
                  */
-                if (newint_ns > 0 || newint_s > 0) {
-                        req.tv_sec = newint_s;
-                        req.tv_nsec = newint_ns;
+                if (timeleft > 0) {
+                        struct timespec req;
+
+                        req.tv_sec = (time_t)(timeleft / 1000000000.0);
+                        req.tv_nsec = (long)(timeleft - (req.tv_sec * 1000000000.0));
 
                         res = nanosleep(&req, NULL);
                         if (res) {
@@ -451,7 +447,7 @@ int main(int argc, char *argv[]) {
                 } else {
                         overrun++;
                         /* calculate how many samples we lost and scrap them */
-                        arg_samples_len -= (int)(newint_ns / interval);
+                        arg_samples_len -= (int)(-timeleft / interval);
                 }
                 LIST_PREPEND(link, head, sampledata);
         }
